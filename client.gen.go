// Package goda provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package goda

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListDocAnalytics request
	ListDocAnalytics(ctx context.Context, params *ListDocAnalyticsParams) (*http.Response, error)

	// ListCategories request
	ListCategories(ctx context.Context) (*http.Response, error)

	// ListDocs request
	ListDocs(ctx context.Context, params *ListDocsParams) (*http.Response, error)

	// CreateDoc request  with any body
	CreateDocWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateDoc(ctx context.Context, body CreateDocJSONRequestBody) (*http.Response, error)

	// DeleteDoc request
	DeleteDoc(ctx context.Context, docId DocId) (*http.Response, error)

	// GetDoc request
	GetDoc(ctx context.Context, docId DocId) (*http.Response, error)

	// GetAclMetadata request
	GetAclMetadata(ctx context.Context, docId DocId) (*http.Response, error)

	// GetAclPermissions request
	GetAclPermissions(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*http.Response, error)

	// ShareDoc request  with any body
	ShareDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error)

	ShareDoc(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*http.Response, error)

	// DeletePermission request
	DeletePermission(ctx context.Context, docId DocId, permissionId PermissionId) (*http.Response, error)

	// ListControls request
	ListControls(ctx context.Context, docId DocId, params *ListControlsParams) (*http.Response, error)

	// GetControl request
	GetControl(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*http.Response, error)

	// ListFormulas request
	ListFormulas(ctx context.Context, docId DocId, params *ListFormulasParams) (*http.Response, error)

	// GetFormula request
	GetFormula(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Response, error)

	// ListPages request
	ListPages(ctx context.Context, docId DocId, params *ListPagesParams) (*http.Response, error)

	// GetPage request
	GetPage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*http.Response, error)

	// UpdatePage request  with any body
	UpdatePageWithBody(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Response, error)

	UpdatePage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Response, error)

	// UnpublishDoc request
	UnpublishDoc(ctx context.Context, docId DocId) (*http.Response, error)

	// PublishDoc request  with any body
	PublishDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error)

	PublishDoc(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, docId DocId, params *ListTablesParams) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*http.Response, error)

	// ListColumns request
	ListColumns(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Response, error)

	// GetColumn request
	GetColumn(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error)

	// DeleteRows request  with any body
	DeleteRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Response, error)

	DeleteRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Response, error)

	// ListRows request
	ListRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Response, error)

	// UpsertRows request  with any body
	UpsertRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Response, error)

	UpsertRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Response, error)

	// DeleteRow request
	DeleteRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Response, error)

	// GetRow request
	GetRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Response, error)

	// UpdateRow request  with any body
	UpdateRowWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Response, error)

	// PushButton request
	PushButton(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error)

	// GetMutationStatus request
	GetMutationStatus(ctx context.Context, requestId RequestId) (*http.Response, error)

	// ResolveBrowserLink request
	ResolveBrowserLink(ctx context.Context, params *ResolveBrowserLinkParams) (*http.Response, error)

	// Whoami request
	Whoami(ctx context.Context) (*http.Response, error)
}

func (c *Client) ListDocAnalytics(ctx context.Context, params *ListDocAnalyticsParams) (*http.Response, error) {
	req, err := NewListDocAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListCategories(ctx context.Context) (*http.Response, error) {
	req, err := NewListCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListDocs(ctx context.Context, params *ListDocsParams) (*http.Response, error) {
	req, err := NewListDocsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateDocRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDoc(ctx context.Context, body CreateDocJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateDocRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDoc(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewDeleteDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetDoc(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewGetDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclMetadata(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewGetAclMetadataRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclPermissions(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*http.Response, error) {
	req, err := NewGetAclPermissionsRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ShareDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewShareDocRequestWithBody(c.Server, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ShareDoc(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*http.Response, error) {
	req, err := NewShareDocRequest(c.Server, docId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePermission(ctx context.Context, docId DocId, permissionId PermissionId) (*http.Response, error) {
	req, err := NewDeletePermissionRequest(c.Server, docId, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListControls(ctx context.Context, docId DocId, params *ListControlsParams) (*http.Response, error) {
	req, err := NewListControlsRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetControl(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*http.Response, error) {
	req, err := NewGetControlRequest(c.Server, docId, controlIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListFormulas(ctx context.Context, docId DocId, params *ListFormulasParams) (*http.Response, error) {
	req, err := NewListFormulasRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetFormula(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Response, error) {
	req, err := NewGetFormulaRequest(c.Server, docId, formulaIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListPages(ctx context.Context, docId DocId, params *ListPagesParams) (*http.Response, error) {
	req, err := NewListPagesRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*http.Response, error) {
	req, err := NewGetPageRequest(c.Server, docId, pageIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePageWithBody(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdatePageRequestWithBody(c.Server, docId, pageIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdatePageRequest(c.Server, docId, pageIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UnpublishDoc(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewUnpublishDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PublishDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPublishDocRequestWithBody(c.Server, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PublishDoc(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*http.Response, error) {
	req, err := NewPublishDocRequest(c.Server, docId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, docId DocId, params *ListTablesParams) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, docId, tableIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListColumns(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Response, error) {
	req, err := NewListColumnsRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumn(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error) {
	req, err := NewGetColumnRequest(c.Server, docId, tableIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewDeleteRowsRequestWithBody(c.Server, docId, tableIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Response, error) {
	req, err := NewDeleteRowsRequest(c.Server, docId, tableIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Response, error) {
	req, err := NewListRowsRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpsertRowsRequestWithBody(c.Server, docId, tableIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Response, error) {
	req, err := NewUpsertRowsRequest(c.Server, docId, tableIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Response, error) {
	req, err := NewDeleteRowRequest(c.Server, docId, tableIdOrName, rowIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Response, error) {
	req, err := NewGetRowRequest(c.Server, docId, tableIdOrName, rowIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRowWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateRowRequestWithBody(c.Server, docId, tableIdOrName, rowIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateRowRequest(c.Server, docId, tableIdOrName, rowIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PushButton(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error) {
	req, err := NewPushButtonRequest(c.Server, docId, tableIdOrName, rowIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMutationStatus(ctx context.Context, requestId RequestId) (*http.Response, error) {
	req, err := NewGetMutationStatusRequest(c.Server, requestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveBrowserLink(ctx context.Context, params *ResolveBrowserLinkParams) (*http.Response, error) {
	req, err := NewResolveBrowserLinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Whoami(ctx context.Context) (*http.Response, error) {
	req, err := NewWhoamiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewListDocAnalyticsRequest generates requests for ListDocAnalytics
func NewListDocAnalyticsRequest(server string, params *ListDocAnalyticsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/analytics/docs")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.IsPublished != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "isPublished", *params.IsPublished); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SinceDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sinceDate", *params.SinceDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UntilDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "untilDate", *params.UntilDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCategoriesRequest generates requests for ListCategories
func NewListCategoriesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/categories")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDocsRequest generates requests for ListDocs
func NewListDocsRequest(server string, params *ListDocsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.IsOwner != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "isOwner", *params.IsOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SourceDoc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sourceDoc", *params.SourceDoc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsStarred != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "isStarred", *params.IsStarred); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InGallery != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "inGallery", *params.InGallery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.WorkspaceId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "workspaceId", *params.WorkspaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FolderId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "folderId", *params.FolderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDocRequest calls the generic CreateDoc builder with application/json body
func NewCreateDocRequest(server string, body CreateDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDocRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDocRequestWithBody generates requests for CreateDoc with any type of body
func NewCreateDocRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteDocRequest generates requests for DeleteDoc
func NewDeleteDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDocRequest generates requests for GetDoc
func NewGetDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclMetadataRequest generates requests for GetAclMetadata
func NewGetAclMetadataRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/metadata", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclPermissionsRequest generates requests for GetAclPermissions
func NewGetAclPermissionsRequest(server string, docId DocId, params *GetAclPermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/permissions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareDocRequest calls the generic ShareDoc builder with application/json body
func NewShareDocRequest(server string, docId DocId, body ShareDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareDocRequestWithBody(server, docId, "application/json", bodyReader)
}

// NewShareDocRequestWithBody generates requests for ShareDoc with any type of body
func NewShareDocRequestWithBody(server string, docId DocId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/permissions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeletePermissionRequest generates requests for DeletePermission
func NewDeletePermissionRequest(server string, docId DocId, permissionId PermissionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "permissionId", permissionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/permissions/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListControlsRequest generates requests for ListControls
func NewListControlsRequest(server string, docId DocId, params *ListControlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/controls", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetControlRequest generates requests for GetControl
func NewGetControlRequest(server string, docId DocId, controlIdOrName ControlIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "controlIdOrName", controlIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/controls/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFormulasRequest generates requests for ListFormulas
func NewListFormulasRequest(server string, docId DocId, params *ListFormulasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/formulas", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFormulaRequest generates requests for GetFormula
func NewGetFormulaRequest(server string, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "formulaIdOrName", formulaIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/formulas/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPagesRequest generates requests for ListPages
func NewListPagesRequest(server string, docId DocId, params *ListPagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/pages", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageRequest generates requests for GetPage
func NewGetPageRequest(server string, docId DocId, pageIdOrName PageIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pageIdOrName", pageIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/pages/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePageRequest calls the generic UpdatePage builder with application/json body
func NewUpdatePageRequest(server string, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePageRequestWithBody(server, docId, pageIdOrName, "application/json", bodyReader)
}

// NewUpdatePageRequestWithBody generates requests for UpdatePage with any type of body
func NewUpdatePageRequestWithBody(server string, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pageIdOrName", pageIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/pages/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUnpublishDocRequest generates requests for UnpublishDoc
func NewUnpublishDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/publish", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishDocRequest calls the generic PublishDoc builder with application/json body
func NewPublishDocRequest(server string, docId DocId, body PublishDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishDocRequestWithBody(server, docId, "application/json", bodyReader)
}

// NewPublishDocRequestWithBody generates requests for PublishDoc with any type of body
func NewPublishDocRequestWithBody(server string, docId DocId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/publish", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, docId DocId, params *ListTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TableTypes != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "tableTypes", *params.TableTypes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, docId DocId, tableIdOrName TableIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListColumnsRequest generates requests for ListColumns
func NewListColumnsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/columns", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleOnly != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "visibleOnly", *params.VisibleOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnRequest generates requests for GetColumn
func NewGetColumnRequest(server string, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "columnIdOrName", columnIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/columns/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRowsRequest calls the generic DeleteRows builder with application/json body
func NewDeleteRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRowsRequestWithBody(server, docId, tableIdOrName, "application/json", bodyReader)
}

// NewDeleteRowsRequestWithBody generates requests for DeleteRows with any type of body
func NewDeleteRowsRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListRowsRequest generates requests for ListRows
func NewListRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UseColumnNames != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "useColumnNames", *params.UseColumnNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ValueFormat != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "valueFormat", *params.ValueFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleOnly != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "visibleOnly", *params.VisibleOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertRowsRequest calls the generic UpsertRows builder with application/json body
func NewUpsertRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertRowsRequestWithBody(server, docId, tableIdOrName, params, "application/json", bodyReader)
}

// NewUpsertRowsRequestWithBody generates requests for UpsertRows with any type of body
func NewUpsertRowsRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.DisableParsing != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "disableParsing", *params.DisableParsing); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteRowRequest generates requests for DeleteRow
func NewDeleteRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRowRequest generates requests for GetRow
func NewGetRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.UseColumnNames != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "useColumnNames", *params.UseColumnNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ValueFormat != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "valueFormat", *params.ValueFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRowRequest calls the generic UpdateRow builder with application/json body
func NewUpdateRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRowRequestWithBody(server, docId, tableIdOrName, rowIdOrName, params, "application/json", bodyReader)
}

// NewUpdateRowRequestWithBody generates requests for UpdateRow with any type of body
func NewUpdateRowRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.DisableParsing != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "disableParsing", *params.DisableParsing); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPushButtonRequest generates requests for PushButton
func NewPushButtonRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParam("simple", false, "columnIdOrName", columnIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s/buttons/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMutationStatusRequest generates requests for GetMutationStatus
func NewGetMutationStatusRequest(server string, requestId RequestId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "requestId", requestId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/mutationStatus/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveBrowserLinkRequest generates requests for ResolveBrowserLink
func NewResolveBrowserLinkRequest(server string, params *ResolveBrowserLinkParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/resolveBrowserLink")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "url", params.Url); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DegradeGracefully != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "degradeGracefully", *params.DegradeGracefully); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoamiRequest generates requests for Whoami
func NewWhoamiRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/whoami")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListDocAnalytics request
	ListDocAnalyticsWithResponse(ctx context.Context, params *ListDocAnalyticsParams) (*ListDocAnalyticsResponse, error)

	// ListCategories request
	ListCategoriesWithResponse(ctx context.Context) (*ListCategoriesResponse, error)

	// ListDocs request
	ListDocsWithResponse(ctx context.Context, params *ListDocsParams) (*ListDocsResponse, error)

	// CreateDoc request  with any body
	CreateDocWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateDocResponse, error)

	CreateDocWithResponse(ctx context.Context, body CreateDocJSONRequestBody) (*CreateDocResponse, error)

	// DeleteDoc request
	DeleteDocWithResponse(ctx context.Context, docId DocId) (*DeleteDocResponse, error)

	// GetDoc request
	GetDocWithResponse(ctx context.Context, docId DocId) (*GetDocResponse, error)

	// GetAclMetadata request
	GetAclMetadataWithResponse(ctx context.Context, docId DocId) (*GetAclMetadataResponse, error)

	// GetAclPermissions request
	GetAclPermissionsWithResponse(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*GetAclPermissionsResponse, error)

	// ShareDoc request  with any body
	ShareDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*ShareDocResponse, error)

	ShareDocWithResponse(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*ShareDocResponse, error)

	// DeletePermission request
	DeletePermissionWithResponse(ctx context.Context, docId DocId, permissionId PermissionId) (*DeletePermissionResponse, error)

	// ListControls request
	ListControlsWithResponse(ctx context.Context, docId DocId, params *ListControlsParams) (*ListControlsResponse, error)

	// GetControl request
	GetControlWithResponse(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*GetControlResponse, error)

	// ListFormulas request
	ListFormulasWithResponse(ctx context.Context, docId DocId, params *ListFormulasParams) (*ListFormulasResponse, error)

	// GetFormula request
	GetFormulaWithResponse(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*GetFormulaResponse, error)

	// ListPages request
	ListPagesWithResponse(ctx context.Context, docId DocId, params *ListPagesParams) (*ListPagesResponse, error)

	// GetPage request
	GetPageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*GetPageResponse, error)

	// UpdatePage request  with any body
	UpdatePageWithBodyWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*UpdatePageResponse, error)

	UpdatePageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*UpdatePageResponse, error)

	// UnpublishDoc request
	UnpublishDocWithResponse(ctx context.Context, docId DocId) (*UnpublishDocResponse, error)

	// PublishDoc request  with any body
	PublishDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*PublishDocResponse, error)

	PublishDocWithResponse(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*PublishDocResponse, error)

	// ListTables request
	ListTablesWithResponse(ctx context.Context, docId DocId, params *ListTablesParams) (*ListTablesResponse, error)

	// GetTable request
	GetTableWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*GetTableResponse, error)

	// ListColumns request
	ListColumnsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*ListColumnsResponse, error)

	// GetColumn request
	GetColumnWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*GetColumnResponse, error)

	// DeleteRows request  with any body
	DeleteRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*DeleteRowsResponse, error)

	DeleteRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*DeleteRowsResponse, error)

	// ListRows request
	ListRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*ListRowsResponse, error)

	// UpsertRows request  with any body
	UpsertRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*UpsertRowsResponse, error)

	UpsertRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*UpsertRowsResponse, error)

	// DeleteRow request
	DeleteRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*DeleteRowResponse, error)

	// GetRow request
	GetRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*GetRowResponse, error)

	// UpdateRow request  with any body
	UpdateRowWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*UpdateRowResponse, error)

	UpdateRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*UpdateRowResponse, error)

	// PushButton request
	PushButtonWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*PushButtonResponse, error)

	// GetMutationStatus request
	GetMutationStatusWithResponse(ctx context.Context, requestId RequestId) (*GetMutationStatusResponse, error)

	// ResolveBrowserLink request
	ResolveBrowserLinkWithResponse(ctx context.Context, params *ResolveBrowserLinkParams) (*ResolveBrowserLinkResponse, error)

	// Whoami request
	WhoamiWithResponse(ctx context.Context) (*WhoamiResponse, error)
}

type ListDocAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocAnalyticsDaily
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocCategoryList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Doc
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DocDelete
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Doc
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclMetadata
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAclMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAclPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddPermissionResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ShareDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePermissionResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListControlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControlList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListControlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListControlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Control
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFormulasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FormulaList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFormulasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFormulasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFormulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Formula
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFormulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFormulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON410 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PageUpdateResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpublishDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnpublishResult
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UnpublishDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpublishDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PublishResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r PublishDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnDetail
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowsDeleteResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowList
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowsUpsertResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpsertRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowDeleteResult
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowDetail
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowUpdateResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushButtonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PushButtonResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r PushButtonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushButtonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMutationStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MutationStatus
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMutationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMutationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveBrowserLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiLink
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ResolveBrowserLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveBrowserLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r WhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListDocAnalyticsWithResponse request returning *ListDocAnalyticsResponse
func (c *ClientWithResponses) ListDocAnalyticsWithResponse(ctx context.Context, params *ListDocAnalyticsParams) (*ListDocAnalyticsResponse, error) {
	rsp, err := c.ListDocAnalytics(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListDocAnalyticsResponse(rsp)
}

// ListCategoriesWithResponse request returning *ListCategoriesResponse
func (c *ClientWithResponses) ListCategoriesWithResponse(ctx context.Context) (*ListCategoriesResponse, error) {
	rsp, err := c.ListCategories(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListCategoriesResponse(rsp)
}

// ListDocsWithResponse request returning *ListDocsResponse
func (c *ClientWithResponses) ListDocsWithResponse(ctx context.Context, params *ListDocsParams) (*ListDocsResponse, error) {
	rsp, err := c.ListDocs(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListDocsResponse(rsp)
}

// CreateDocWithBodyWithResponse request with arbitrary body returning *CreateDocResponse
func (c *ClientWithResponses) CreateDocWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateDocResponse, error) {
	rsp, err := c.CreateDocWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocResponse(rsp)
}

func (c *ClientWithResponses) CreateDocWithResponse(ctx context.Context, body CreateDocJSONRequestBody) (*CreateDocResponse, error) {
	rsp, err := c.CreateDoc(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocResponse(rsp)
}

// DeleteDocWithResponse request returning *DeleteDocResponse
func (c *ClientWithResponses) DeleteDocWithResponse(ctx context.Context, docId DocId) (*DeleteDocResponse, error) {
	rsp, err := c.DeleteDoc(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDocResponse(rsp)
}

// GetDocWithResponse request returning *GetDocResponse
func (c *ClientWithResponses) GetDocWithResponse(ctx context.Context, docId DocId) (*GetDocResponse, error) {
	rsp, err := c.GetDoc(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseGetDocResponse(rsp)
}

// GetAclMetadataWithResponse request returning *GetAclMetadataResponse
func (c *ClientWithResponses) GetAclMetadataWithResponse(ctx context.Context, docId DocId) (*GetAclMetadataResponse, error) {
	rsp, err := c.GetAclMetadata(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseGetAclMetadataResponse(rsp)
}

// GetAclPermissionsWithResponse request returning *GetAclPermissionsResponse
func (c *ClientWithResponses) GetAclPermissionsWithResponse(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*GetAclPermissionsResponse, error) {
	rsp, err := c.GetAclPermissions(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetAclPermissionsResponse(rsp)
}

// ShareDocWithBodyWithResponse request with arbitrary body returning *ShareDocResponse
func (c *ClientWithResponses) ShareDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*ShareDocResponse, error) {
	rsp, err := c.ShareDocWithBody(ctx, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseShareDocResponse(rsp)
}

func (c *ClientWithResponses) ShareDocWithResponse(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*ShareDocResponse, error) {
	rsp, err := c.ShareDoc(ctx, docId, body)
	if err != nil {
		return nil, err
	}
	return ParseShareDocResponse(rsp)
}

// DeletePermissionWithResponse request returning *DeletePermissionResponse
func (c *ClientWithResponses) DeletePermissionWithResponse(ctx context.Context, docId DocId, permissionId PermissionId) (*DeletePermissionResponse, error) {
	rsp, err := c.DeletePermission(ctx, docId, permissionId)
	if err != nil {
		return nil, err
	}
	return ParseDeletePermissionResponse(rsp)
}

// ListControlsWithResponse request returning *ListControlsResponse
func (c *ClientWithResponses) ListControlsWithResponse(ctx context.Context, docId DocId, params *ListControlsParams) (*ListControlsResponse, error) {
	rsp, err := c.ListControls(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListControlsResponse(rsp)
}

// GetControlWithResponse request returning *GetControlResponse
func (c *ClientWithResponses) GetControlWithResponse(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*GetControlResponse, error) {
	rsp, err := c.GetControl(ctx, docId, controlIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetControlResponse(rsp)
}

// ListFormulasWithResponse request returning *ListFormulasResponse
func (c *ClientWithResponses) ListFormulasWithResponse(ctx context.Context, docId DocId, params *ListFormulasParams) (*ListFormulasResponse, error) {
	rsp, err := c.ListFormulas(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListFormulasResponse(rsp)
}

// GetFormulaWithResponse request returning *GetFormulaResponse
func (c *ClientWithResponses) GetFormulaWithResponse(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*GetFormulaResponse, error) {
	rsp, err := c.GetFormula(ctx, docId, formulaIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetFormulaResponse(rsp)
}

// ListPagesWithResponse request returning *ListPagesResponse
func (c *ClientWithResponses) ListPagesWithResponse(ctx context.Context, docId DocId, params *ListPagesParams) (*ListPagesResponse, error) {
	rsp, err := c.ListPages(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPagesResponse(rsp)
}

// GetPageWithResponse request returning *GetPageResponse
func (c *ClientWithResponses) GetPageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*GetPageResponse, error) {
	rsp, err := c.GetPage(ctx, docId, pageIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetPageResponse(rsp)
}

// UpdatePageWithBodyWithResponse request with arbitrary body returning *UpdatePageResponse
func (c *ClientWithResponses) UpdatePageWithBodyWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePageWithBody(ctx, docId, pageIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

func (c *ClientWithResponses) UpdatePageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePage(ctx, docId, pageIdOrName, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

// UnpublishDocWithResponse request returning *UnpublishDocResponse
func (c *ClientWithResponses) UnpublishDocWithResponse(ctx context.Context, docId DocId) (*UnpublishDocResponse, error) {
	rsp, err := c.UnpublishDoc(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseUnpublishDocResponse(rsp)
}

// PublishDocWithBodyWithResponse request with arbitrary body returning *PublishDocResponse
func (c *ClientWithResponses) PublishDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*PublishDocResponse, error) {
	rsp, err := c.PublishDocWithBody(ctx, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePublishDocResponse(rsp)
}

func (c *ClientWithResponses) PublishDocWithResponse(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*PublishDocResponse, error) {
	rsp, err := c.PublishDoc(ctx, docId, body)
	if err != nil {
		return nil, err
	}
	return ParsePublishDocResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, docId DocId, params *ListTablesParams) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, docId, tableIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ListColumnsWithResponse request returning *ListColumnsResponse
func (c *ClientWithResponses) ListColumnsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*ListColumnsResponse, error) {
	rsp, err := c.ListColumns(ctx, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	return ParseListColumnsResponse(rsp)
}

// GetColumnWithResponse request returning *GetColumnResponse
func (c *ClientWithResponses) GetColumnWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*GetColumnResponse, error) {
	rsp, err := c.GetColumn(ctx, docId, tableIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnResponse(rsp)
}

// DeleteRowsWithBodyWithResponse request with arbitrary body returning *DeleteRowsResponse
func (c *ClientWithResponses) DeleteRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRowsWithBody(ctx, docId, tableIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

func (c *ClientWithResponses) DeleteRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRows(ctx, docId, tableIdOrName, body)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

// ListRowsWithResponse request returning *ListRowsResponse
func (c *ClientWithResponses) ListRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*ListRowsResponse, error) {
	rsp, err := c.ListRows(ctx, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	return ParseListRowsResponse(rsp)
}

// UpsertRowsWithBodyWithResponse request with arbitrary body returning *UpsertRowsResponse
func (c *ClientWithResponses) UpsertRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*UpsertRowsResponse, error) {
	rsp, err := c.UpsertRowsWithBody(ctx, docId, tableIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRowsResponse(rsp)
}

func (c *ClientWithResponses) UpsertRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*UpsertRowsResponse, error) {
	rsp, err := c.UpsertRows(ctx, docId, tableIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRowsResponse(rsp)
}

// DeleteRowWithResponse request returning *DeleteRowResponse
func (c *ClientWithResponses) DeleteRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*DeleteRowResponse, error) {
	rsp, err := c.DeleteRow(ctx, docId, tableIdOrName, rowIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowResponse(rsp)
}

// GetRowWithResponse request returning *GetRowResponse
func (c *ClientWithResponses) GetRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*GetRowResponse, error) {
	rsp, err := c.GetRow(ctx, docId, tableIdOrName, rowIdOrName, params)
	if err != nil {
		return nil, err
	}
	return ParseGetRowResponse(rsp)
}

// UpdateRowWithBodyWithResponse request with arbitrary body returning *UpdateRowResponse
func (c *ClientWithResponses) UpdateRowWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*UpdateRowResponse, error) {
	rsp, err := c.UpdateRowWithBody(ctx, docId, tableIdOrName, rowIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*UpdateRowResponse, error) {
	rsp, err := c.UpdateRow(ctx, docId, tableIdOrName, rowIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowResponse(rsp)
}

// PushButtonWithResponse request returning *PushButtonResponse
func (c *ClientWithResponses) PushButtonWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*PushButtonResponse, error) {
	rsp, err := c.PushButton(ctx, docId, tableIdOrName, rowIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	return ParsePushButtonResponse(rsp)
}

// GetMutationStatusWithResponse request returning *GetMutationStatusResponse
func (c *ClientWithResponses) GetMutationStatusWithResponse(ctx context.Context, requestId RequestId) (*GetMutationStatusResponse, error) {
	rsp, err := c.GetMutationStatus(ctx, requestId)
	if err != nil {
		return nil, err
	}
	return ParseGetMutationStatusResponse(rsp)
}

// ResolveBrowserLinkWithResponse request returning *ResolveBrowserLinkResponse
func (c *ClientWithResponses) ResolveBrowserLinkWithResponse(ctx context.Context, params *ResolveBrowserLinkParams) (*ResolveBrowserLinkResponse, error) {
	rsp, err := c.ResolveBrowserLink(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseResolveBrowserLinkResponse(rsp)
}

// WhoamiWithResponse request returning *WhoamiResponse
func (c *ClientWithResponses) WhoamiWithResponse(ctx context.Context) (*WhoamiResponse, error) {
	rsp, err := c.Whoami(ctx)
	if err != nil {
		return nil, err
	}
	return ParseWhoamiResponse(rsp)
}

// ParseListDocAnalyticsResponse parses an HTTP response from a ListDocAnalyticsWithResponse call
func ParseListDocAnalyticsResponse(rsp *http.Response) (*ListDocAnalyticsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDocAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocAnalyticsDaily
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListCategoriesResponse parses an HTTP response from a ListCategoriesWithResponse call
func ParseListCategoriesResponse(rsp *http.Response) (*ListCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocCategoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListDocsResponse parses an HTTP response from a ListDocsWithResponse call
func ParseListDocsResponse(rsp *http.Response) (*ListDocsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateDocResponse parses an HTTP response from a CreateDocWithResponse call
func ParseCreateDocResponse(rsp *http.Response) (*CreateDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Doc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteDocResponse parses an HTTP response from a DeleteDocWithResponse call
func ParseDeleteDocResponse(rsp *http.Response) (*DeleteDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DocDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetDocResponse parses an HTTP response from a GetDocWithResponse call
func ParseGetDocResponse(rsp *http.Response) (*GetDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Doc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAclMetadataResponse parses an HTTP response from a GetAclMetadataWithResponse call
func ParseGetAclMetadataResponse(rsp *http.Response) (*GetAclMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAclMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAclPermissionsResponse parses an HTTP response from a GetAclPermissionsWithResponse call
func ParseGetAclPermissionsResponse(rsp *http.Response) (*GetAclPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAclPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseShareDocResponse parses an HTTP response from a ShareDocWithResponse call
func ParseShareDocResponse(rsp *http.Response) (*ShareDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShareDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddPermissionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeletePermissionResponse parses an HTTP response from a DeletePermissionWithResponse call
func ParseDeletePermissionResponse(rsp *http.Response) (*DeletePermissionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePermissionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListControlsResponse parses an HTTP response from a ListControlsWithResponse call
func ParseListControlsResponse(rsp *http.Response) (*ListControlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListControlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetControlResponse parses an HTTP response from a GetControlWithResponse call
func ParseGetControlResponse(rsp *http.Response) (*GetControlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Control
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListFormulasResponse parses an HTTP response from a ListFormulasWithResponse call
func ParseListFormulasResponse(rsp *http.Response) (*ListFormulasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListFormulasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormulaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetFormulaResponse parses an HTTP response from a GetFormulaWithResponse call
func ParseGetFormulaResponse(rsp *http.Response) (*GetFormulaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetFormulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Formula
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListPagesResponse parses an HTTP response from a ListPagesWithResponse call
func ParseListPagesResponse(rsp *http.Response) (*ListPagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPageResponse parses an HTTP response from a GetPageWithResponse call
func ParseGetPageResponse(rsp *http.Response) (*GetPageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdatePageResponse parses an HTTP response from a UpdatePageWithResponse call
func ParseUpdatePageResponse(rsp *http.Response) (*UpdatePageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PageUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUnpublishDocResponse parses an HTTP response from a UnpublishDocWithResponse call
func ParseUnpublishDocResponse(rsp *http.Response) (*UnpublishDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UnpublishDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnpublishResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePublishDocResponse parses an HTTP response from a PublishDocWithResponse call
func ParsePublishDocResponse(rsp *http.Response) (*PublishDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PublishDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PublishResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListColumnsResponse parses an HTTP response from a ListColumnsWithResponse call
func ParseListColumnsResponse(rsp *http.Response) (*ListColumnsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetColumnResponse parses an HTTP response from a GetColumnWithResponse call
func ParseGetColumnResponse(rsp *http.Response) (*GetColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRowsResponse parses an HTTP response from a DeleteRowsWithResponse call
func ParseDeleteRowsResponse(rsp *http.Response) (*DeleteRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowsDeleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListRowsResponse parses an HTTP response from a ListRowsWithResponse call
func ParseListRowsResponse(rsp *http.Response) (*ListRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpsertRowsResponse parses an HTTP response from a UpsertRowsWithResponse call
func ParseUpsertRowsResponse(rsp *http.Response) (*UpsertRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpsertRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowsUpsertResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRowResponse parses an HTTP response from a DeleteRowWithResponse call
func ParseDeleteRowResponse(rsp *http.Response) (*DeleteRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowDeleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetRowResponse parses an HTTP response from a GetRowWithResponse call
func ParseGetRowResponse(rsp *http.Response) (*GetRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdateRowResponse parses an HTTP response from a UpdateRowWithResponse call
func ParseUpdateRowResponse(rsp *http.Response) (*UpdateRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePushButtonResponse parses an HTTP response from a PushButtonWithResponse call
func ParsePushButtonResponse(rsp *http.Response) (*PushButtonResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PushButtonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PushButtonResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMutationStatusResponse parses an HTTP response from a GetMutationStatusWithResponse call
func ParseGetMutationStatusResponse(rsp *http.Response) (*GetMutationStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMutationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MutationStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseResolveBrowserLinkResponse parses an HTTP response from a ResolveBrowserLinkWithResponse call
func ParseResolveBrowserLinkResponse(rsp *http.Response) (*ResolveBrowserLinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResolveBrowserLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWhoamiResponse parses an HTTP response from a WhoamiWithResponse call
func ParseWhoamiResponse(rsp *http.Response) (*WhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &WhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

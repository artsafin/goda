// Package goda provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package goda

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// AccessType defines model for AccessType.
type AccessType string

// List of AccessType
const (
	AccessType_comment  AccessType = "comment"
	AccessType_none     AccessType = "none"
	AccessType_readonly AccessType = "readonly"
	AccessType_write    AccessType = "write"
)

// Acl defines model for Acl.
type Acl struct {

	// API link to these results
	Href         string       `json:"href"`
	Items        []Permission `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// AclMetadata defines model for AclMetadata.
type AclMetadata struct {

	// When true, the user of the api can share
	CanShare bool `json:"canShare"`

	// When true, the user of the api can share with the org
	CanShareWithOrg bool `json:"canShareWithOrg"`
}

// AddPermission defines model for AddPermission.
type AddPermission struct {

	// Type of access.
	Access AccessType `json:"access"`

	// Metadata about a principal.
	Principal Principal `json:"principal"`

	// When true suppresses email notification
	SuppressEmail *bool `json:"suppressEmail,omitempty"`
}

// AddPermissionResult defines model for AddPermissionResult.
type AddPermissionResult map[string]interface{}

// AnyonePrincipal defines model for AnyonePrincipal.
type AnyonePrincipal struct {

	// Type of principal.
	Type PrincipalType `json:"type"`
}

// ApiLink defines model for ApiLink.
type ApiLink struct {

	// Canonical browser-friendly link to the resolved resource.
	BrowserLink *string `json:"browserLink,omitempty"`

	// Self link to this query.
	Href string `json:"href"`

	// Reference to the resolved resource.
	Resource ApiLinkResolvedResource `json:"resource"`

	// The type of this resource.
	Type string `json:"type"`
}

// ApiLinkResolvedResource defines model for ApiLinkResolvedResource.
type ApiLinkResolvedResource struct {

	// API link to the resolved resource that can be queried to get further information.
	Href string `json:"href"`

	// ID of the resolved resource.
	Id string `json:"id"`

	// Name of the resource.
	Name *string `json:"name,omitempty"`

	// A constant identifying the type of the resource.
	Type Type `json:"type"`
}

// CellEdit defines model for CellEdit.
type CellEdit struct {

	// Column ID, URL, or name (fragile and discouraged) associated with this edit.
	Column string `json:"column"`

	// A Coda result or entity expressed as a primitive type, or array of primitive types.
	Value Value `json:"value"`
}

// CellValue defines model for CellValue.
type CellValue interface{}

// Column defines model for Column.
type Column struct {

	// Whether the column has a formula set on it.
	Calculated *bool `json:"calculated,omitempty"`

	// Whether the column is the display column.
	Display *bool `json:"display,omitempty"`

	// Format of a column.
	Format ColumnFormat `json:"format"`

	// API link to the column.
	Href string `json:"href"`

	// ID of the column.
	Id string `json:"id"`

	// Name of the column.
	Name string `json:"name"`

	// The type of this resource.
	Type string `json:"type"`
}

// ColumnDetail defines model for ColumnDetail.
type ColumnDetail struct {

	// Whether the column has a formula set on it.
	Calculated *bool `json:"calculated,omitempty"`

	// Whether the column is the display column.
	Display *bool `json:"display,omitempty"`

	// Format of a column.
	Format ColumnFormat `json:"format"`

	// API link to the column.
	Href string `json:"href"`

	// ID of the column.
	Id string `json:"id"`

	// Name of the column.
	Name string `json:"name"`

	// Reference to a table or view.
	Parent TableReference `json:"parent"`

	// The type of this resource.
	Type string `json:"type"`
}

// ColumnFormat defines model for ColumnFormat.
type ColumnFormat interface{}

// ColumnFormatType defines model for ColumnFormatType.
type ColumnFormatType string

// List of ColumnFormatType
const (
	ColumnFormatType__select    ColumnFormatType = "select"
	ColumnFormatType_button     ColumnFormatType = "button"
	ColumnFormatType_checkbox   ColumnFormatType = "checkbox"
	ColumnFormatType_currency   ColumnFormatType = "currency"
	ColumnFormatType_date       ColumnFormatType = "date"
	ColumnFormatType_dateTime   ColumnFormatType = "dateTime"
	ColumnFormatType_duration   ColumnFormatType = "duration"
	ColumnFormatType_image      ColumnFormatType = "image"
	ColumnFormatType_lookup     ColumnFormatType = "lookup"
	ColumnFormatType_number     ColumnFormatType = "number"
	ColumnFormatType_other      ColumnFormatType = "other"
	ColumnFormatType_packObject ColumnFormatType = "packObject"
	ColumnFormatType_percent    ColumnFormatType = "percent"
	ColumnFormatType_person     ColumnFormatType = "person"
	ColumnFormatType_scale      ColumnFormatType = "scale"
	ColumnFormatType_slider     ColumnFormatType = "slider"
	ColumnFormatType_text       ColumnFormatType = "text"
	ColumnFormatType_time       ColumnFormatType = "time"
)

// ColumnList defines model for ColumnList.
type ColumnList struct {

	// API link to these results
	Href         *string  `json:"href,omitempty"`
	Items        []Column `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// ColumnReference defines model for ColumnReference.
type ColumnReference struct {

	// API link to the column.
	Href string `json:"href"`

	// ID of the column.
	Id string `json:"id"`

	// The type of this resource.
	Type string `json:"type"`
}

// Control defines model for Control.
type Control struct {

	// Type of the control.
	ControlType ControlType `json:"controlType"`

	// API link to the control.
	Href string `json:"href"`

	// ID of the control.
	Id string `json:"id"`

	// Name of the control.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type string `json:"type"`

	// A Coda result or entity expressed as a primitive type, or array of primitive types.
	Value Value `json:"value"`
}

// ControlList defines model for ControlList.
type ControlList struct {

	// API link to these results
	Href         *string            `json:"href,omitempty"`
	Items        []ControlReference `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// ControlReference defines model for ControlReference.
type ControlReference struct {

	// API link to the control.
	Href string `json:"href"`

	// ID of the control.
	Id string `json:"id"`

	// Name of the control.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type string `json:"type"`
}

// ControlType defines model for ControlType.
type ControlType string

// List of ControlType
const (
	ControlType__select         ControlType = "select"
	ControlType_button          ControlType = "button"
	ControlType_checkbox        ControlType = "checkbox"
	ControlType_datePicker      ControlType = "datePicker"
	ControlType_dateRangePicker ControlType = "dateRangePicker"
	ControlType_multiselect     ControlType = "multiselect"
	ControlType_scale           ControlType = "scale"
	ControlType_slider          ControlType = "slider"
)

// CurrencyAmount defines model for CurrencyAmount.
type CurrencyAmount interface{}

// CurrencyColumnFormat defines model for CurrencyColumnFormat.
type CurrencyColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema

	// The currency symbol
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// How the numeric value should be formatted (with or without symbol, negative numbers in parens).
	Format *CurrencyFormatType `json:"format,omitempty"`

	// The decimal precision.
	Precision *int `json:"precision,omitempty"`
}

// CurrencyFormatType defines model for CurrencyFormatType.
type CurrencyFormatType string

// List of CurrencyFormatType
const (
	CurrencyFormatType_accounting CurrencyFormatType = "accounting"
	CurrencyFormatType_currency   CurrencyFormatType = "currency"
	CurrencyFormatType_financial  CurrencyFormatType = "financial"
)

// CurrencyValue defines model for CurrencyValue.
type CurrencyValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject
	// Embedded fields due to inline allOf schema

	// A numeric monetary amount as a string or number.
	Amount CurrencyAmount `json:"amount"`

	// The 3-letter currency code.
	Currency string `json:"currency"`
}

// DateColumnFormat defines model for DateColumnFormat.
type DateColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema

	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	Format *string `json:"format,omitempty"`
}

// DateTimeColumnFormat defines model for DateTimeColumnFormat.
type DateTimeColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema

	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	DateFormat *string `json:"dateFormat,omitempty"`

	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	TimeFormat *string `json:"timeFormat,omitempty"`
}

// DeletePermissionResult defines model for DeletePermissionResult.
type DeletePermissionResult map[string]interface{}

// Doc defines model for Doc.
type Doc struct {

	// Browser-friendly link to the Coda doc.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the doc was created.
	CreatedAt time.Time `json:"createdAt"`

	// The number of components within a Coda doc.
	DocSize *DocSize `json:"docSize,omitempty"`

	// API link to the Coda doc.
	Href string `json:"href"`

	// Info about the icon.
	Icon *Icon `json:"icon,omitempty"`

	// ID of the Coda doc.
	Id string `json:"id"`

	// Name of the doc.
	Name string `json:"name"`

	// Email address of the doc owner.
	Owner openapi_types.Email `json:"owner"`

	// Name of the doc owner.
	OwnerName string `json:"ownerName"`

	// Information about the publishing state of the document.
	Published *DocPublished `json:"published,omitempty"`
	SourceDoc *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/DocReference)
		DocReference
	} `json:"sourceDoc,omitempty"`

	// The type of this resource.
	Type string `json:"type"`

	// Timestamp for when the doc was last modified.
	UpdatedAt time.Time `json:"updatedAt"`
}

// DocAnalyticsDaily defines model for DocAnalyticsDaily.
type DocAnalyticsDaily struct {
	Items        []DocAnalyticsDay `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// DocAnalyticsDay defines model for DocAnalyticsDay.
type DocAnalyticsDay struct {

	// Number of times the doc was copied on the given date.
	Copies int `json:"copies"`

	// Date of the analytics data.
	Date openapi_types.Date `json:"date"`
	Doc  struct {
		// Embedded struct due to allOf(#/components/schemas/DocReference)
		DocReference
		// Embedded fields due to inline allOf schema

		// Title of the doc.
		Title string `json:"title"`
	} `json:"doc"`

	// Number of times the doc was liked on the given date.
	Likes int `json:"likes"`

	// Number of times the doc was viewed on the given date.
	Views int `json:"views"`
}

// DocCategory defines model for DocCategory.
type DocCategory struct {

	// Name of the category.
	Name string `json:"name"`
}

// DocCategoryList defines model for DocCategoryList.
type DocCategoryList struct {

	// Categories for the doc.
	Items []DocCategory `json:"items"`
}

// DocCreate defines model for DocCreate.
type DocCreate struct {

	// The ID of the folder within which to create this doc. Defaults to your "My Docs" folder in the oldest workspace you joined; this is subject to change. You can get this ID by opening the folder in the docs list on your computer and grabbing the `folderId` query parameter.
	FolderId *string `json:"folderId,omitempty"`

	// An optional doc ID from which to create a copy.
	SourceDoc *string `json:"sourceDoc,omitempty"`

	// The timezone to use for the newly created doc.
	Timezone *string `json:"timezone,omitempty"`

	// Title of the new doc. Defaults to 'Untitled'.
	Title *string `json:"title,omitempty"`
}

// DocDelete defines model for DocDelete.
type DocDelete map[string]interface{}

// DocList defines model for DocList.
type DocList struct {

	// API link to these results
	Href         *string `json:"href,omitempty"`
	Items        []Doc   `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// DocPublish defines model for DocPublish.
type DocPublish struct {

	// The names of categories to apply to the document.
	CategoryNames *[]string `json:"categoryNames,omitempty"`

	// If true, the doc will display a copy button in the header.
	Copyable *bool `json:"copyable,omitempty"`

	// If true, indicates that the doc is discoverable.
	Discoverable *bool `json:"discoverable,omitempty"`

	// If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
	EarnCredit *bool `json:"earnCredit,omitempty"`

	// A time unit used as part of a duration value.
	Mode *DocPublishMode `json:"mode,omitempty"`

	// Slug for the published doc.
	Slug *string `json:"slug,omitempty"`
}

// DocPublishMode defines model for DocPublishMode.
type DocPublishMode string

// List of DocPublishMode
const (
	DocPublishMode_edit DocPublishMode = "edit"
	DocPublishMode_play DocPublishMode = "play"
	DocPublishMode_view DocPublishMode = "view"
)

// DocPublished defines model for DocPublished.
type DocPublished struct {

	// URL to the published doc.
	BrowserLink string `json:"browserLink"`

	// Categories applied to the doc.
	Categories []DocCategory `json:"categories"`

	// If true, the doc will display a copy button in the header.
	Copyable bool `json:"copyable"`

	// Description of the published doc.
	Description *string `json:"description,omitempty"`

	// If true, indicates that the doc is discoverable.
	Discoverable bool `json:"discoverable"`

	// If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
	EarnCredit bool `json:"earnCredit"`

	// URL to the cover image for the published doc.
	ImageLink *string `json:"imageLink,omitempty"`

	// A time unit used as part of a duration value.
	Mode DocPublishMode `json:"mode"`
}

// DocReference defines model for DocReference.
type DocReference struct {

	// Browser-friendly link to the Coda doc.
	BrowserLink string `json:"browserLink"`

	// API link to the Coda doc.
	Href string `json:"href"`

	// ID of the Coda doc.
	Id string `json:"id"`

	// The type of this resource.
	Type string `json:"type"`
}

// DocSize defines model for DocSize.
type DocSize struct {

	// If true, indicates that the doc is over the API size limit.
	OverApiSizeLimit bool `json:"overApiSizeLimit"`

	// The total number of page contained within the doc.
	PageCount float32 `json:"pageCount"`

	// The total number of tables and views contained within the doc.
	TableAndViewCount float32 `json:"tableAndViewCount"`

	// The number of rows contained within all tables of the doc.
	TotalRowCount float32 `json:"totalRowCount"`
}

// DocumentMutateResponse defines model for DocumentMutateResponse.
type DocumentMutateResponse struct {

	// An arbitrary unique identifier for this request.
	RequestId string `json:"requestId"`
}

// DomainPrincipal defines model for DomainPrincipal.
type DomainPrincipal struct {

	// Domain for the principal.
	Domain string `json:"domain"`

	// Type of principal.
	Type PrincipalType `json:"type"`
}

// DurationColumnFormat defines model for DurationColumnFormat.
type DurationColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema
	MaxUnit *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/DurationUnit)
		DurationUnit
	} `json:"maxUnit,omitempty"`
	Precision *int `json:"precision,omitempty"`
}

// DurationUnit defines model for DurationUnit.
type DurationUnit string

// List of DurationUnit
const (
	DurationUnit_days    DurationUnit = "days"
	DurationUnit_hours   DurationUnit = "hours"
	DurationUnit_minutes DurationUnit = "minutes"
	DurationUnit_seconds DurationUnit = "seconds"
)

// EmailPrincipal defines model for EmailPrincipal.
type EmailPrincipal struct {

	// Email for the principal.
	Email string `json:"email"`

	// Type of principal.
	Type PrincipalType `json:"type"`
}

// Formula defines model for Formula.
type Formula struct {

	// API link to the formula.
	Href string `json:"href"`

	// ID of the formula.
	Id string `json:"id"`

	// Name of the formula.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type string `json:"type"`

	// A Coda result or entity expressed as a primitive type, or array of primitive types.
	Value Value `json:"value"`
}

// FormulaDetail defines model for FormulaDetail.
type FormulaDetail struct {

	// Returns whether or not the given formula has a Now() formula within it.
	HasNowFormula *bool `json:"hasNowFormula,omitempty"`

	// Returns whether or not the given formula has a Today() formula within it.
	HasTodayFormula *bool `json:"hasTodayFormula,omitempty"`

	// Returns whether or not the given formula has a User() formula within it.
	HasUserFormula *bool `json:"hasUserFormula,omitempty"`

	// Returns whether or not the given formula can return different results in different contexts (for example, for different users).
	IsVolatile *bool `json:"isVolatile,omitempty"`

	// Returns whether or not the given formula is valid.
	Valid bool `json:"valid"`
}

// FormulaList defines model for FormulaList.
type FormulaList struct {

	// API link to these results
	Href         *string            `json:"href,omitempty"`
	Items        []FormulaReference `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// FormulaReference defines model for FormulaReference.
type FormulaReference struct {

	// API link to the formula.
	Href string `json:"href"`

	// ID of the formula.
	Id string `json:"id"`

	// Name of the formula.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// The type of this resource.
	Type string `json:"type"`
}

// Icon defines model for Icon.
type Icon struct {

	// Browser-friendly link to an icon.
	BrowserLink string `json:"browserLink"`

	// Name of the icon.
	Name string `json:"name"`

	// MIME type of the icon
	Type string `json:"type"`
}

// IconSet defines model for IconSet.
type IconSet string

// List of IconSet
const (
	IconSet_battery   IconSet = "battery"
	IconSet_bell      IconSet = "bell"
	IconSet_bug       IconSet = "bug"
	IconSet_checkmark IconSet = "checkmark"
	IconSet_chili     IconSet = "chili"
	IconSet_circle    IconSet = "circle"
	IconSet_cloud     IconSet = "cloud"
	IconSet_cocktail  IconSet = "cocktail"
	IconSet_coffee    IconSet = "coffee"
	IconSet_currency  IconSet = "currency"
	IconSet_diamond   IconSet = "diamond"
	IconSet_fire      IconSet = "fire"
	IconSet_heart     IconSet = "heart"
	IconSet_lightbulb IconSet = "lightbulb"
	IconSet_lightning IconSet = "lightning"
	IconSet_person    IconSet = "person"
	IconSet_smiley    IconSet = "smiley"
	IconSet_star      IconSet = "star"
	IconSet_sun       IconSet = "sun"
	IconSet_thumbsup  IconSet = "thumbsup"
)

// Image defines model for Image.
type Image struct {

	// Browser-friendly link to an image.
	BrowserLink string `json:"browserLink"`

	// The height in pixels of the image.
	Height *float32 `json:"height,omitempty"`

	// MIME type of the image.
	Type *string `json:"type,omitempty"`

	// The width in pixels of the image.
	Width *float32 `json:"width,omitempty"`
}

// ImageStatus defines model for ImageStatus.
type ImageStatus string

// List of ImageStatus
const (
	ImageStatus_deleted ImageStatus = "deleted"
	ImageStatus_failed  ImageStatus = "failed"
	ImageStatus_live    ImageStatus = "live"
)

// ImageUrlValue defines model for ImageUrlValue.
type ImageUrlValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject
	// Embedded fields due to inline allOf schema

	// The height of the image in pixels.
	Height *float32 `json:"height,omitempty"`

	// The name of the image.
	Name *string `json:"name,omitempty"`

	// The status values that an image object can have.
	Status *ImageStatus `json:"status,omitempty"`

	// The url of the image.
	Url *string `json:"url,omitempty"`

	// The width of the image in pixels.
	Width *float32 `json:"width,omitempty"`
}

// Layout defines model for Layout.
type Layout string

// List of Layout
const (
	Layout__default     Layout = "default"
	Layout_areaChart    Layout = "areaChart"
	Layout_barChart     Layout = "barChart"
	Layout_bubbleChart  Layout = "bubbleChart"
	Layout_calendar     Layout = "calendar"
	Layout_card         Layout = "card"
	Layout_ganttChart   Layout = "ganttChart"
	Layout_lineChart    Layout = "lineChart"
	Layout_masterDetail Layout = "masterDetail"
	Layout_pieChart     Layout = "pieChart"
	Layout_scatterChart Layout = "scatterChart"
	Layout_slide        Layout = "slide"
	Layout_wordCloud    Layout = "wordCloud"
)

// LinkedDataObject defines model for LinkedDataObject.
type LinkedDataObject struct {

	// A url describing the schema context for this object, typically "http://schema.org/".
	Context string `json:"@context"`

	// A schema.org identifier for the object.
	Type LinkedDataType `json:"@type"`

	// An identifier of additional type info specific to Coda that may not be present in a schema.org taxonomy,
	AdditionalType *string `json:"additionalType,omitempty"`
}

// LinkedDataType defines model for LinkedDataType.
type LinkedDataType string

// List of LinkedDataType
const (
	LinkedDataType_ImageObject     LinkedDataType = "ImageObject"
	LinkedDataType_MonetaryAmount  LinkedDataType = "MonetaryAmount"
	LinkedDataType_Person          LinkedDataType = "Person"
	LinkedDataType_StructuredValue LinkedDataType = "StructuredValue"
	LinkedDataType_WebPage         LinkedDataType = "WebPage"
)

// MutationStatus defines model for MutationStatus.
type MutationStatus struct {

	// Returns whether the mutation has completed.
	Completed bool `json:"completed"`
}

// NumberOrNumberFormula defines model for NumberOrNumberFormula.
type NumberOrNumberFormula interface{}

// NumericColumnFormat defines model for NumericColumnFormat.
type NumericColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema

	// The decimal precision.
	Precision *int `json:"precision,omitempty"`

	// Whether to use a thousands separator (like ",") to format the numeric value.
	UseThousandsSeparator *bool `json:"useThousandsSeparator,omitempty"`
}

// Page defines model for Page.
type Page struct {

	// Browser-friendly link to the page.
	BrowserLink string          `json:"browserLink"`
	Children    []PageReference `json:"children"`

	// API link to the page.
	Href string `json:"href"`

	// Info about the icon.
	Icon *Icon `json:"icon,omitempty"`

	// ID of the page.
	Id string `json:"id"`

	// Info about the image.
	Image *Image `json:"image,omitempty"`

	// Name of the page.
	Name string `json:"name"`

	// Reference to a page.
	Parent *PageReference `json:"parent,omitempty"`

	// Subtitle of the page.
	Subtitle *string `json:"subtitle,omitempty"`

	// The type of this resource.
	Type string `json:"type"`
}

// PageList defines model for PageList.
type PageList struct {

	// API link to these results
	Href         *string `json:"href,omitempty"`
	Items        []Page  `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// PageReference defines model for PageReference.
type PageReference struct {

	// Browser-friendly link to the page.
	BrowserLink string `json:"browserLink"`

	// API link to the page.
	Href string `json:"href"`

	// ID of the page.
	Id string `json:"id"`

	// Name of the page.
	Name string `json:"name"`

	// The type of this resource.
	Type string `json:"type"`
}

// PageUpdate defines model for PageUpdate.
type PageUpdate struct {

	// Name of the icon.
	IconName *string `json:"iconName,omitempty"`

	// Url of the image to use.
	ImageUrl *string `json:"imageUrl,omitempty"`

	// Name of the page.
	Name *string `json:"name,omitempty"`

	// Subtitle of the page.
	Subtitle *string `json:"subtitle,omitempty"`
}

// PageUpdateResult defines model for PageUpdateResult.
type PageUpdateResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
	// Embedded fields due to inline allOf schema

	// ID of the updated page.
	Id string `json:"id"`
}

// Permission defines model for Permission.
type Permission struct {

	// Type of access.
	Access AccessType `json:"access"`

	// Id for the Permission
	Id string `json:"id"`

	// Metadata about a principal.
	Principal Principal `json:"principal"`
}

// PersonValue defines model for PersonValue.
type PersonValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject
	// Embedded fields due to inline allOf schema

	// The email address of the person.
	Email string `json:"email"`

	// The full name of the person.
	Name string `json:"name"`
}

// Principal defines model for Principal.
type Principal interface{}

// PrincipalType defines model for PrincipalType.
type PrincipalType string

// List of PrincipalType
const (
	PrincipalType_anyone PrincipalType = "anyone"
	PrincipalType_domain PrincipalType = "domain"
	PrincipalType_email  PrincipalType = "email"
)

// PublishResult defines model for PublishResult.
type PublishResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
	// Embedded fields due to inline allOf schema
}

// PushButtonResult defines model for PushButtonResult.
type PushButtonResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
	// Embedded fields due to inline allOf schema

	// ID of the column where the button exists.
	ColumnId string `json:"columnId"`

	// ID of the row where the button exists.
	RowId string `json:"rowId"`
}

// ReferenceColumnFormat defines model for ReferenceColumnFormat.
type ReferenceColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema
	Table struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/TableReference)
		TableReference
	} `json:"table"`
}

// RichSingleValue defines model for RichSingleValue.
type RichSingleValue interface{}

// RichValue defines model for RichValue.
type RichValue interface{}

// Row defines model for Row.
type Row struct {

	// Browser-friendly link to the row.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the row was created.
	CreatedAt time.Time `json:"createdAt"`

	// API link to the row.
	Href string `json:"href"`

	// ID of the row.
	Id string `json:"id"`

	// Index of the row within the table.
	Index int `json:"index"`

	// The display name of the row, based on its identifying column.
	Name string `json:"name"`

	// The type of this resource.
	Type string `json:"type"`

	// Timestamp for when the row was last modified.
	UpdatedAt time.Time `json:"updatedAt"`

	// Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
	Values map[string]interface{} `json:"values"`
}

// RowDeleteResult defines model for RowDeleteResult.
type RowDeleteResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
	// Embedded fields due to inline allOf schema

	// ID of the row to be deleted.
	Id string `json:"id"`
}

// RowDetail defines model for RowDetail.
type RowDetail struct {

	// Browser-friendly link to the row.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the row was created.
	CreatedAt time.Time `json:"createdAt"`

	// API link to the row.
	Href string `json:"href"`

	// ID of the row.
	Id string `json:"id"`

	// Index of the row within the table.
	Index int `json:"index"`

	// The display name of the row, based on its identifying column.
	Name string `json:"name"`

	// Reference to a table or view.
	Parent TableReference `json:"parent"`

	// The type of this resource.
	Type string `json:"type"`

	// Timestamp for when the row was last modified.
	UpdatedAt time.Time `json:"updatedAt"`

	// Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
	Values map[string]interface{} `json:"values"`
}

// RowEdit defines model for RowEdit.
type RowEdit struct {
	Cells []CellEdit `json:"cells"`
}

// RowList defines model for RowList.
type RowList struct {

	// API link to these results
	Href         *string `json:"href,omitempty"`
	Items        []Row   `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// RowUpdate defines model for RowUpdate.
type RowUpdate struct {

	// An edit made to a particular row.
	Row RowEdit `json:"row"`
}

// RowUpdateResult defines model for RowUpdateResult.
type RowUpdateResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
	// Embedded fields due to inline allOf schema

	// ID of the updated row.
	Id string `json:"id"`
}

// RowValue defines model for RowValue.
type RowValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject
	// Embedded fields due to inline allOf schema

	// The type of this resource.
	AdditionalType string `json:"additionalType"`

	// The display name of the row, based on its identifying column.
	Name string `json:"name"`

	// The ID of the table
	RowId string `json:"rowId"`

	// The ID of the table
	TableId string `json:"tableId"`

	// The url of the table.
	TableUrl string `json:"tableUrl"`

	// The url of the row.
	Url string `json:"url"`
}

// RowsDelete defines model for RowsDelete.
type RowsDelete struct {

	// Row IDs to delete.
	RowIds []string `json:"rowIds"`
}

// RowsDeleteResult defines model for RowsDeleteResult.
type RowsDeleteResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
	// Embedded fields due to inline allOf schema

	// Row IDs to delete.
	RowIds []string `json:"rowIds"`
}

// RowsSortBy defines model for RowsSortBy.
type RowsSortBy string

// List of RowsSortBy
const (
	RowsSortBy_createdAt RowsSortBy = "createdAt"
	RowsSortBy_natural   RowsSortBy = "natural"
)

// RowsUpsert defines model for RowsUpsert.
type RowsUpsert struct {

	// Optional column IDs, URLs, or names (fragile and discouraged), specifying columns to be used as upsert keys.
	KeyColumns *[]string `json:"keyColumns,omitempty"`
	Rows       []RowEdit `json:"rows"`
}

// RowsUpsertResult defines model for RowsUpsertResult.
type RowsUpsertResult struct {
	// Embedded struct due to allOf(#/components/schemas/DocumentMutateResponse)
	DocumentMutateResponse
}

// ScalarValue defines model for ScalarValue.
type ScalarValue interface{}

// ScaleColumnFormat defines model for ScaleColumnFormat.
type ScaleColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema
	Icon struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/IconSet)
		IconSet
	} `json:"icon"`

	// The maximum number allowed for this scale.
	Maximum float32 `json:"maximum"`
}

// SimpleColumnFormat defines model for SimpleColumnFormat.
type SimpleColumnFormat struct {

	// Whether or not this column is an array.
	IsArray bool `json:"isArray"`

	// Format type of the column
	Type ColumnFormatType `json:"type"`
}

// SliderColumnFormat defines model for SliderColumnFormat.
type SliderColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema
	Maximum *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/NumberOrNumberFormula)
		NumberOrNumberFormula
	} `json:"maximum,omitempty"`
	Minimum *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/NumberOrNumberFormula)
		NumberOrNumberFormula
	} `json:"minimum,omitempty"`
	Step *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/NumberOrNumberFormula)
		NumberOrNumberFormula
	} `json:"step,omitempty"`
}

// Sort defines model for Sort.
type Sort struct {

	// Reference to a column.
	Column ColumnReference `json:"column"`

	// Direction of a sort for a table or view.
	Direction SortDirection `json:"direction"`
}

// SortBySchema defines model for SortBySchema.
type SortBySchema string

// List of SortBySchema
const (
	SortBySchema_name SortBySchema = "name"
)

// SortDirection defines model for SortDirection.
type SortDirection string

// List of SortDirection
const (
	SortDirection_ascending  SortDirection = "ascending"
	SortDirection_descending SortDirection = "descending"
)

// Table defines model for Table.
type Table struct {

	// Browser-friendly link to the table.
	BrowserLink string `json:"browserLink"`

	// Timestamp for when the table was created.
	CreatedAt time.Time `json:"createdAt"`

	// Reference to a column.
	DisplayColumn ColumnReference `json:"displayColumn"`
	Filter        *struct {
		// Embedded fields due to inline allOf schema
		// Embedded struct due to allOf(#/components/schemas/FormulaDetail)
		FormulaDetail
	} `json:"filter,omitempty"`

	// API link to the table.
	Href string `json:"href"`

	// ID of the table.
	Id string `json:"id"`

	// Layout type of the table or view.
	Layout Layout `json:"layout"`

	// Name of the table.
	Name string `json:"name"`

	// Reference to a page.
	Parent PageReference `json:"parent"`

	// Reference to a table or view.
	ParentTable *TableReference `json:"parentTable,omitempty"`

	// Total number of rows in the table.
	RowCount int `json:"rowCount"`

	// Any sorts applied to the table.
	Sorts     []Sort    `json:"sorts"`
	TableType TableType `json:"tableType"`

	// The type of this resource.
	Type string `json:"type"`

	// Timestamp for when the table was last modified.
	UpdatedAt time.Time `json:"updatedAt"`
}

// TableList defines model for TableList.
type TableList struct {

	// API link to these results
	Href         *string          `json:"href,omitempty"`
	Items        []TableReference `json:"items"`
	NextPageLink *struct {
		// Embedded struct due to allOf(#/components/schemas/nextPageLink)
		NextPageLink
		// Embedded fields due to inline allOf schema
	} `json:"nextPageLink,omitempty"`

	// If specified, an opaque token used to fetch the next page of results.
	NextPageToken *NextPageToken `json:"nextPageToken,omitempty"`
}

// TableReference defines model for TableReference.
type TableReference struct {

	// Browser-friendly link to the table.
	BrowserLink string `json:"browserLink"`

	// API link to the table.
	Href string `json:"href"`

	// ID of the table.
	Id string `json:"id"`

	// Name of the table.
	Name string `json:"name"`

	// Reference to a page.
	Parent    *PageReference `json:"parent,omitempty"`
	TableType TableType      `json:"tableType"`

	// The type of this resource.
	Type string `json:"type"`
}

// TableType defines model for TableType.
type TableType string

// List of TableType
const (
	TableType_table TableType = "table"
	TableType_view  TableType = "view"
)

// TimeColumnFormat defines model for TimeColumnFormat.
type TimeColumnFormat struct {
	// Embedded struct due to allOf(#/components/schemas/SimpleColumnFormat)
	SimpleColumnFormat
	// Embedded fields due to inline allOf schema

	// A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
	Format *string `json:"format,omitempty"`
}

// Type defines model for Type.
type Type string

// List of Type
const (
	Type_aclMetadata    Type = "aclMetadata"
	Type_aclPermissions Type = "aclPermissions"
	Type_apiLink        Type = "apiLink"
	Type_column         Type = "column"
	Type_control        Type = "control"
	Type_doc            Type = "doc"
	Type_docAnalytics   Type = "docAnalytics"
	Type_formula        Type = "formula"
	Type_mutationStatus Type = "mutationStatus"
	Type_page           Type = "page"
	Type_row            Type = "row"
	Type_table          Type = "table"
	Type_user           Type = "user"
	Type_workspace      Type = "workspace"
)

// UnpublishResult defines model for UnpublishResult.
type UnpublishResult map[string]interface{}

// UrlValue defines model for UrlValue.
type UrlValue struct {
	// Embedded struct due to allOf(#/components/schemas/LinkedDataObject)
	LinkedDataObject
	// Embedded fields due to inline allOf schema

	// The user-visible text of the hyperlink.
	Name *string `json:"name,omitempty"`

	// The url of the hyperlink.
	Url string `json:"url"`
}

// User defines model for User.
type User struct {

	// API link to the user.
	Href string `json:"href"`

	// Email address of the user.
	LoginId string `json:"loginId"`

	// Name of the user.
	Name string `json:"name"`

	// Browser-friendly link to the user's avatar image.
	PictureLink *string `json:"pictureLink,omitempty"`

	// True if the token used to make this request has restricted/scoped access to the API.
	Scoped bool `json:"scoped"`

	// Returns the name of the token used for this request.
	TokenName string `json:"tokenName"`

	// The type of this resource.
	Type string `json:"type"`

	// Reference to a Coda workspace.
	Workspace WorkspaceReference `json:"workspace"`
}

// Value defines model for Value.
type Value interface{}

// ValueFormat defines model for ValueFormat.
type ValueFormat string

// List of ValueFormat
const (
	ValueFormat_rich             ValueFormat = "rich"
	ValueFormat_simple           ValueFormat = "simple"
	ValueFormat_simpleWithArrays ValueFormat = "simpleWithArrays"
)

// Workspace defines model for Workspace.
type Workspace struct {

	// Browser-friendly link to the Coda workspace.
	BrowserLink string `json:"browserLink"`

	// Description of the workspace.
	Description *string `json:"description,omitempty"`

	// ID of the Coda workspace.
	Id string `json:"id"`

	// Name of the workspace.
	Name string `json:"name"`

	// The type of this resource.
	Type string `json:"type"`
}

// WorkspaceReference defines model for WorkspaceReference.
type WorkspaceReference struct {

	// Browser-friendly link to the Coda workspace.
	BrowserLink string `json:"browserLink"`

	// ID of the Coda workspace.
	Id string `json:"id"`

	// The type of this resource.
	Type string `json:"type"`
}

// NextPageLink defines model for nextPageLink.
type NextPageLink string

// NextPageToken defines model for nextPageToken.
type NextPageToken string

// ColumnIdOrName defines model for columnIdOrName.
type ColumnIdOrName string

// ControlIdOrName defines model for controlIdOrName.
type ControlIdOrName string

// DocId defines model for docId.
type DocId string

// FormulaIdOrName defines model for formulaIdOrName.
type FormulaIdOrName string

// Limit defines model for limit.
type Limit int

// PageIdOrName defines model for pageIdOrName.
type PageIdOrName string

// PageToken defines model for pageToken.
type PageToken string

// PermissionId defines model for permissionId.
type PermissionId string

// RequestId defines model for requestId.
type RequestId string

// RowIdOrName defines model for rowIdOrName.
type RowIdOrName string

// SortBy defines model for sortBy.
type SortBy SortBySchema

// TableIdOrName defines model for tableIdOrName.
type TableIdOrName string

// TableTypes defines model for tableTypes.
type TableTypes []TableType

// UseColumnNames defines model for useColumnNames.
type UseColumnNames bool

// ViewIdOrName defines model for viewIdOrName.
type ViewIdOrName string

// BadRequestError defines model for BadRequestError.
type BadRequestError struct {

	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// ForbiddenError defines model for ForbiddenError.
type ForbiddenError struct {

	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// GoneError defines model for GoneError.
type GoneError struct {

	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// NotFoundError defines model for NotFoundError.
type NotFoundError struct {

	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// TooManyRequestsError defines model for TooManyRequestsError.
type TooManyRequestsError struct {

	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError struct {

	// Any additional context on the error, or the same as `statusMessage` otherwise.
	Message string `json:"message"`

	// HTTP status code of the error.
	StatusCode float32 `json:"statusCode"`

	// HTTP status message of the error.
	StatusMessage string `json:"statusMessage"`
}

// ListDocAnalyticsParams defines parameters for ListDocAnalytics.
type ListDocAnalyticsParams struct {

	// Show analytics only for published docs.
	IsPublished *bool `json:"isPublished,omitempty"`

	// Limit results to activity on or after this date.
	SinceDate *openapi_types.Date `json:"sinceDate,omitempty"`

	// Limit results to activity on or before this date.
	UntilDate *openapi_types.Date `json:"untilDate,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// ListDocsParams defines parameters for ListDocs.
type ListDocsParams struct {

	// Show only docs owned by the user.
	IsOwner *bool `json:"isOwner,omitempty"`

	// Search term used to filter down results.
	Query *string `json:"query,omitempty"`

	// Show only docs copied from the specified doc ID.
	SourceDoc *string `json:"sourceDoc,omitempty"`

	// If true, returns docs that are starred. If false, returns docs that are not starred.
	IsStarred *bool `json:"isStarred,omitempty"`

	// Show only docs visible within the gallery.
	InGallery *bool `json:"inGallery,omitempty"`

	// Show only docs belonging to the given workspace.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// Show only docs belonging to the given folder.
	FolderId *string `json:"folderId,omitempty"`

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// CreateDocJSONBody defines parameters for CreateDoc.
type CreateDocJSONBody DocCreate

// GetAclPermissionsParams defines parameters for GetAclPermissions.
type GetAclPermissionsParams struct {

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// ShareDocJSONBody defines parameters for ShareDoc.
type ShareDocJSONBody AddPermission

// ListControlsParams defines parameters for ListControls.
type ListControlsParams struct {

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// Determines how to sort the given objects.
	SortBy *SortBy `json:"sortBy,omitempty"`
}

// ListFormulasParams defines parameters for ListFormulas.
type ListFormulasParams struct {

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// Determines how to sort the given objects.
	SortBy *SortBy `json:"sortBy,omitempty"`
}

// ListPagesParams defines parameters for ListPages.
type ListPagesParams struct {

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// UpdatePageJSONBody defines parameters for UpdatePage.
type UpdatePageJSONBody PageUpdate

// PublishDocJSONBody defines parameters for PublishDoc.
type PublishDocJSONBody DocPublish

// ListTablesParams defines parameters for ListTables.
type ListTablesParams struct {

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// Determines how to sort the given objects.
	SortBy *SortBy `json:"sortBy,omitempty"`

	// Comma-separated list of table types to include in results. If omitted, includes both tables and views.
	TableTypes *TableTypes `json:"tableTypes,omitempty"`
}

// ListColumnsParams defines parameters for ListColumns.
type ListColumnsParams struct {

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`

	// If true, returns only visible columns for the table.
	VisibleOnly *bool `json:"visibleOnly,omitempty"`
}

// DeleteRowsJSONBody defines parameters for DeleteRows.
type DeleteRowsJSONBody RowsDelete

// ListRowsParams defines parameters for ListRows.
type ListRowsParams struct {

	// Query used to filter returned rows, specified as `<column_id_or_name>:<value>`. If you'd like to use a column name instead of an ID, you must quote it (e.g., `"My Column":123`). Also note that `value` is a JSON value; if you'd like to use a string, you must surround it in quotes (e.g., `"groceries"`).
	Query *string `json:"query,omitempty"`

	// Specifies the sort order of the rows returned. If left unspecified, rows are returned by creation time ascending. "Natural" sort ordering is the order that the rows appear in the table view in the application. This ordering is only meaningfully defined for rows that are visible (unfiltered). Because of this, using this sort order will imply visibleOnly=true, that is, to only return visible rows. If you pass sortBy=natural and visibleOnly=false explicitly, this will result in a Bad Request error as this condition cannot be satisfied.
	SortBy *RowsSortBy `json:"sortBy,omitempty"`

	// Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
	UseColumnNames *UseColumnNames `json:"useColumnNames,omitempty"`

	// The format that cell values are returned as.
	ValueFormat *ValueFormat `json:"valueFormat,omitempty"`

	// If true, returns only visible rows and columns for the table.
	VisibleOnly *bool `json:"visibleOnly,omitempty"`

	// Maximum number of results to return in this query.
	Limit *Limit `json:"limit,omitempty"`

	// An opaque token used to fetch the next page of results.
	PageToken *PageToken `json:"pageToken,omitempty"`
}

// UpsertRowsJSONBody defines parameters for UpsertRows.
type UpsertRowsJSONBody RowsUpsert

// UpsertRowsParams defines parameters for UpsertRows.
type UpsertRowsParams struct {

	// If true, the API will not attempt to parse the data in any way.
	DisableParsing *bool `json:"disableParsing,omitempty"`
}

// GetRowParams defines parameters for GetRow.
type GetRowParams struct {

	// Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
	UseColumnNames *UseColumnNames `json:"useColumnNames,omitempty"`

	// The format that cell values are returned as.
	ValueFormat *ValueFormat `json:"valueFormat,omitempty"`
}

// UpdateRowJSONBody defines parameters for UpdateRow.
type UpdateRowJSONBody RowUpdate

// UpdateRowParams defines parameters for UpdateRow.
type UpdateRowParams struct {

	// If true, the API will not attempt to parse the data in any way.
	DisableParsing *bool `json:"disableParsing,omitempty"`
}

// ResolveBrowserLinkParams defines parameters for ResolveBrowserLink.
type ResolveBrowserLinkParams struct {

	// The browser link to try to resolve.
	Url string `json:"url"`

	// By default, attempting to resolve the Coda URL of a deleted object will result in an error. If this flag is set, the next-available object, all the way up to the doc itself, will be resolved.
	DegradeGracefully *bool `json:"degradeGracefully,omitempty"`
}

// CreateDocRequestBody defines body for CreateDoc for application/json ContentType.
type CreateDocJSONRequestBody CreateDocJSONBody

// ShareDocRequestBody defines body for ShareDoc for application/json ContentType.
type ShareDocJSONRequestBody ShareDocJSONBody

// UpdatePageRequestBody defines body for UpdatePage for application/json ContentType.
type UpdatePageJSONRequestBody UpdatePageJSONBody

// PublishDocRequestBody defines body for PublishDoc for application/json ContentType.
type PublishDocJSONRequestBody PublishDocJSONBody

// DeleteRowsRequestBody defines body for DeleteRows for application/json ContentType.
type DeleteRowsJSONRequestBody DeleteRowsJSONBody

// UpsertRowsRequestBody defines body for UpsertRows for application/json ContentType.
type UpsertRowsJSONRequestBody UpsertRowsJSONBody

// UpdateRowRequestBody defines body for UpdateRow for application/json ContentType.
type UpdateRowJSONRequestBody UpdateRowJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListDocAnalytics request
	ListDocAnalytics(ctx context.Context, params *ListDocAnalyticsParams) (*http.Response, error)

	// ListCategories request
	ListCategories(ctx context.Context) (*http.Response, error)

	// ListDocs request
	ListDocs(ctx context.Context, params *ListDocsParams) (*http.Response, error)

	// CreateDoc request  with any body
	CreateDocWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateDoc(ctx context.Context, body CreateDocJSONRequestBody) (*http.Response, error)

	// DeleteDoc request
	DeleteDoc(ctx context.Context, docId DocId) (*http.Response, error)

	// GetDoc request
	GetDoc(ctx context.Context, docId DocId) (*http.Response, error)

	// GetAclMetadata request
	GetAclMetadata(ctx context.Context, docId DocId) (*http.Response, error)

	// GetAclPermissions request
	GetAclPermissions(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*http.Response, error)

	// ShareDoc request  with any body
	ShareDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error)

	ShareDoc(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*http.Response, error)

	// DeletePermission request
	DeletePermission(ctx context.Context, docId DocId, permissionId PermissionId) (*http.Response, error)

	// ListControls request
	ListControls(ctx context.Context, docId DocId, params *ListControlsParams) (*http.Response, error)

	// GetControl request
	GetControl(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*http.Response, error)

	// ListFormulas request
	ListFormulas(ctx context.Context, docId DocId, params *ListFormulasParams) (*http.Response, error)

	// GetFormula request
	GetFormula(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Response, error)

	// ListPages request
	ListPages(ctx context.Context, docId DocId, params *ListPagesParams) (*http.Response, error)

	// GetPage request
	GetPage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*http.Response, error)

	// UpdatePage request  with any body
	UpdatePageWithBody(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Response, error)

	UpdatePage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Response, error)

	// UnpublishDoc request
	UnpublishDoc(ctx context.Context, docId DocId) (*http.Response, error)

	// PublishDoc request  with any body
	PublishDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error)

	PublishDoc(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, docId DocId, params *ListTablesParams) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*http.Response, error)

	// ListColumns request
	ListColumns(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Response, error)

	// GetColumn request
	GetColumn(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error)

	// DeleteRows request  with any body
	DeleteRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Response, error)

	DeleteRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Response, error)

	// ListRows request
	ListRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Response, error)

	// UpsertRows request  with any body
	UpsertRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Response, error)

	UpsertRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Response, error)

	// DeleteRow request
	DeleteRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Response, error)

	// GetRow request
	GetRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Response, error)

	// UpdateRow request  with any body
	UpdateRowWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Response, error)

	UpdateRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Response, error)

	// PushButton request
	PushButton(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error)

	// GetMutationStatus request
	GetMutationStatus(ctx context.Context, requestId RequestId) (*http.Response, error)

	// ResolveBrowserLink request
	ResolveBrowserLink(ctx context.Context, params *ResolveBrowserLinkParams) (*http.Response, error)

	// Whoami request
	Whoami(ctx context.Context) (*http.Response, error)
}

func (c *Client) ListDocAnalytics(ctx context.Context, params *ListDocAnalyticsParams) (*http.Response, error) {
	req, err := NewListDocAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListCategories(ctx context.Context) (*http.Response, error) {
	req, err := NewListCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListDocs(ctx context.Context, params *ListDocsParams) (*http.Response, error) {
	req, err := NewListDocsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDocWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateDocRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDoc(ctx context.Context, body CreateDocJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateDocRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDoc(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewDeleteDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetDoc(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewGetDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclMetadata(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewGetAclMetadataRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclPermissions(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*http.Response, error) {
	req, err := NewGetAclPermissionsRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ShareDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewShareDocRequestWithBody(c.Server, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ShareDoc(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*http.Response, error) {
	req, err := NewShareDocRequest(c.Server, docId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePermission(ctx context.Context, docId DocId, permissionId PermissionId) (*http.Response, error) {
	req, err := NewDeletePermissionRequest(c.Server, docId, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListControls(ctx context.Context, docId DocId, params *ListControlsParams) (*http.Response, error) {
	req, err := NewListControlsRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetControl(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*http.Response, error) {
	req, err := NewGetControlRequest(c.Server, docId, controlIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListFormulas(ctx context.Context, docId DocId, params *ListFormulasParams) (*http.Response, error) {
	req, err := NewListFormulasRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetFormula(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Response, error) {
	req, err := NewGetFormulaRequest(c.Server, docId, formulaIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListPages(ctx context.Context, docId DocId, params *ListPagesParams) (*http.Response, error) {
	req, err := NewListPagesRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetPage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*http.Response, error) {
	req, err := NewGetPageRequest(c.Server, docId, pageIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePageWithBody(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdatePageRequestWithBody(c.Server, docId, pageIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePage(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdatePageRequest(c.Server, docId, pageIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UnpublishDoc(ctx context.Context, docId DocId) (*http.Response, error) {
	req, err := NewUnpublishDocRequest(c.Server, docId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PublishDocWithBody(ctx context.Context, docId DocId, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPublishDocRequestWithBody(c.Server, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PublishDoc(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*http.Response, error) {
	req, err := NewPublishDocRequest(c.Server, docId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, docId DocId, params *ListTablesParams) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server, docId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, docId, tableIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListColumns(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Response, error) {
	req, err := NewListColumnsRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetColumn(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error) {
	req, err := NewGetColumnRequest(c.Server, docId, tableIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewDeleteRowsRequestWithBody(c.Server, docId, tableIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Response, error) {
	req, err := NewDeleteRowsRequest(c.Server, docId, tableIdOrName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ListRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Response, error) {
	req, err := NewListRowsRequest(c.Server, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRowsWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpsertRowsRequestWithBody(c.Server, docId, tableIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertRows(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Response, error) {
	req, err := NewUpsertRowsRequest(c.Server, docId, tableIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Response, error) {
	req, err := NewDeleteRowRequest(c.Server, docId, tableIdOrName, rowIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Response, error) {
	req, err := NewGetRowRequest(c.Server, docId, tableIdOrName, rowIdOrName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRowWithBody(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateRowRequestWithBody(c.Server, docId, tableIdOrName, rowIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRow(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateRowRequest(c.Server, docId, tableIdOrName, rowIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PushButton(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Response, error) {
	req, err := NewPushButtonRequest(c.Server, docId, tableIdOrName, rowIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMutationStatus(ctx context.Context, requestId RequestId) (*http.Response, error) {
	req, err := NewGetMutationStatusRequest(c.Server, requestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveBrowserLink(ctx context.Context, params *ResolveBrowserLinkParams) (*http.Response, error) {
	req, err := NewResolveBrowserLinkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Whoami(ctx context.Context) (*http.Response, error) {
	req, err := NewWhoamiRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewListDocAnalyticsRequest generates requests for ListDocAnalytics
func NewListDocAnalyticsRequest(server string, params *ListDocAnalyticsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/analytics/docs")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.IsPublished != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "isPublished", *params.IsPublished); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SinceDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sinceDate", *params.SinceDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UntilDate != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "untilDate", *params.UntilDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCategoriesRequest generates requests for ListCategories
func NewListCategoriesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/categories")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDocsRequest generates requests for ListDocs
func NewListDocsRequest(server string, params *ListDocsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.IsOwner != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "isOwner", *params.IsOwner); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SourceDoc != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sourceDoc", *params.SourceDoc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsStarred != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "isStarred", *params.IsStarred); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InGallery != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "inGallery", *params.InGallery); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.WorkspaceId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "workspaceId", *params.WorkspaceId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FolderId != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "folderId", *params.FolderId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDocRequest calls the generic CreateDoc builder with application/json body
func NewCreateDocRequest(server string, body CreateDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDocRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDocRequestWithBody generates requests for CreateDoc with any type of body
func NewCreateDocRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteDocRequest generates requests for DeleteDoc
func NewDeleteDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDocRequest generates requests for GetDoc
func NewGetDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclMetadataRequest generates requests for GetAclMetadata
func NewGetAclMetadataRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/metadata", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclPermissionsRequest generates requests for GetAclPermissions
func NewGetAclPermissionsRequest(server string, docId DocId, params *GetAclPermissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/permissions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShareDocRequest calls the generic ShareDoc builder with application/json body
func NewShareDocRequest(server string, docId DocId, body ShareDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShareDocRequestWithBody(server, docId, "application/json", bodyReader)
}

// NewShareDocRequestWithBody generates requests for ShareDoc with any type of body
func NewShareDocRequestWithBody(server string, docId DocId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/permissions", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeletePermissionRequest generates requests for DeletePermission
func NewDeletePermissionRequest(server string, docId DocId, permissionId PermissionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "permissionId", permissionId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/acl/permissions/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListControlsRequest generates requests for ListControls
func NewListControlsRequest(server string, docId DocId, params *ListControlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/controls", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetControlRequest generates requests for GetControl
func NewGetControlRequest(server string, docId DocId, controlIdOrName ControlIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "controlIdOrName", controlIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/controls/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFormulasRequest generates requests for ListFormulas
func NewListFormulasRequest(server string, docId DocId, params *ListFormulasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/formulas", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFormulaRequest generates requests for GetFormula
func NewGetFormulaRequest(server string, docId DocId, formulaIdOrName FormulaIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "formulaIdOrName", formulaIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/formulas/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPagesRequest generates requests for ListPages
func NewListPagesRequest(server string, docId DocId, params *ListPagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/pages", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPageRequest generates requests for GetPage
func NewGetPageRequest(server string, docId DocId, pageIdOrName PageIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pageIdOrName", pageIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/pages/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePageRequest calls the generic UpdatePage builder with application/json body
func NewUpdatePageRequest(server string, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePageRequestWithBody(server, docId, pageIdOrName, "application/json", bodyReader)
}

// NewUpdatePageRequestWithBody generates requests for UpdatePage with any type of body
func NewUpdatePageRequestWithBody(server string, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "pageIdOrName", pageIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/pages/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUnpublishDocRequest generates requests for UnpublishDoc
func NewUnpublishDocRequest(server string, docId DocId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/publish", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishDocRequest calls the generic PublishDoc builder with application/json body
func NewPublishDocRequest(server string, docId DocId, body PublishDocJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPublishDocRequestWithBody(server, docId, "application/json", bodyReader)
}

// NewPublishDocRequestWithBody generates requests for PublishDoc with any type of body
func NewPublishDocRequestWithBody(server string, docId DocId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/publish", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string, docId DocId, params *ListTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.TableTypes != nil {

		if queryFrag, err := runtime.StyleParam("form", false, "tableTypes", *params.TableTypes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, docId DocId, tableIdOrName TableIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListColumnsRequest generates requests for ListColumns
func NewListColumnsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/columns", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleOnly != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "visibleOnly", *params.VisibleOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetColumnRequest generates requests for GetColumn
func NewGetColumnRequest(server string, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "columnIdOrName", columnIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/columns/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRowsRequest calls the generic DeleteRows builder with application/json body
func NewDeleteRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRowsRequestWithBody(server, docId, tableIdOrName, "application/json", bodyReader)
}

// NewDeleteRowsRequestWithBody generates requests for DeleteRows with any type of body
func NewDeleteRowsRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewListRowsRequest generates requests for ListRows
func NewListRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SortBy != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "sortBy", *params.SortBy); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UseColumnNames != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "useColumnNames", *params.UseColumnNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ValueFormat != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "valueFormat", *params.ValueFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleOnly != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "visibleOnly", *params.VisibleOnly); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "limit", *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageToken != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "pageToken", *params.PageToken); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpsertRowsRequest calls the generic UpsertRows builder with application/json body
func NewUpsertRowsRequest(server string, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertRowsRequestWithBody(server, docId, tableIdOrName, params, "application/json", bodyReader)
}

// NewUpsertRowsRequestWithBody generates requests for UpsertRows with any type of body
func NewUpsertRowsRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows", pathParam0, pathParam1)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.DisableParsing != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "disableParsing", *params.DisableParsing); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteRowRequest generates requests for DeleteRow
func NewDeleteRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRowRequest generates requests for GetRow
func NewGetRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.UseColumnNames != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "useColumnNames", *params.UseColumnNames); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ValueFormat != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "valueFormat", *params.ValueFormat); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRowRequest calls the generic UpdateRow builder with application/json body
func NewUpdateRowRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRowRequestWithBody(server, docId, tableIdOrName, rowIdOrName, params, "application/json", bodyReader)
}

// NewUpdateRowRequestWithBody generates requests for UpdateRow with any type of body
func NewUpdateRowRequestWithBody(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s", pathParam0, pathParam1, pathParam2)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.DisableParsing != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "disableParsing", *params.DisableParsing); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPushButtonRequest generates requests for PushButton
func NewPushButtonRequest(server string, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "docId", docId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "tableIdOrName", tableIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "rowIdOrName", rowIdOrName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParam("simple", false, "columnIdOrName", columnIdOrName)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/docs/%s/tables/%s/rows/%s/buttons/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMutationStatusRequest generates requests for GetMutationStatus
func NewGetMutationStatusRequest(server string, requestId RequestId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "requestId", requestId)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/mutationStatus/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveBrowserLinkRequest generates requests for ResolveBrowserLink
func NewResolveBrowserLinkRequest(server string, params *ResolveBrowserLinkParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/resolveBrowserLink")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if queryFrag, err := runtime.StyleParam("form", true, "url", params.Url); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.DegradeGracefully != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "degradeGracefully", *params.DegradeGracefully); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWhoamiRequest generates requests for Whoami
func NewWhoamiRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/whoami")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListDocAnalytics request
	ListDocAnalyticsWithResponse(ctx context.Context, params *ListDocAnalyticsParams) (*ListDocAnalyticsResponse, error)

	// ListCategories request
	ListCategoriesWithResponse(ctx context.Context) (*ListCategoriesResponse, error)

	// ListDocs request
	ListDocsWithResponse(ctx context.Context, params *ListDocsParams) (*ListDocsResponse, error)

	// CreateDoc request  with any body
	CreateDocWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateDocResponse, error)

	CreateDocWithResponse(ctx context.Context, body CreateDocJSONRequestBody) (*CreateDocResponse, error)

	// DeleteDoc request
	DeleteDocWithResponse(ctx context.Context, docId DocId) (*DeleteDocResponse, error)

	// GetDoc request
	GetDocWithResponse(ctx context.Context, docId DocId) (*GetDocResponse, error)

	// GetAclMetadata request
	GetAclMetadataWithResponse(ctx context.Context, docId DocId) (*GetAclMetadataResponse, error)

	// GetAclPermissions request
	GetAclPermissionsWithResponse(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*GetAclPermissionsResponse, error)

	// ShareDoc request  with any body
	ShareDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*ShareDocResponse, error)

	ShareDocWithResponse(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*ShareDocResponse, error)

	// DeletePermission request
	DeletePermissionWithResponse(ctx context.Context, docId DocId, permissionId PermissionId) (*DeletePermissionResponse, error)

	// ListControls request
	ListControlsWithResponse(ctx context.Context, docId DocId, params *ListControlsParams) (*ListControlsResponse, error)

	// GetControl request
	GetControlWithResponse(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*GetControlResponse, error)

	// ListFormulas request
	ListFormulasWithResponse(ctx context.Context, docId DocId, params *ListFormulasParams) (*ListFormulasResponse, error)

	// GetFormula request
	GetFormulaWithResponse(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*GetFormulaResponse, error)

	// ListPages request
	ListPagesWithResponse(ctx context.Context, docId DocId, params *ListPagesParams) (*ListPagesResponse, error)

	// GetPage request
	GetPageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*GetPageResponse, error)

	// UpdatePage request  with any body
	UpdatePageWithBodyWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*UpdatePageResponse, error)

	UpdatePageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*UpdatePageResponse, error)

	// UnpublishDoc request
	UnpublishDocWithResponse(ctx context.Context, docId DocId) (*UnpublishDocResponse, error)

	// PublishDoc request  with any body
	PublishDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*PublishDocResponse, error)

	PublishDocWithResponse(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*PublishDocResponse, error)

	// ListTables request
	ListTablesWithResponse(ctx context.Context, docId DocId, params *ListTablesParams) (*ListTablesResponse, error)

	// GetTable request
	GetTableWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*GetTableResponse, error)

	// ListColumns request
	ListColumnsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*ListColumnsResponse, error)

	// GetColumn request
	GetColumnWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*GetColumnResponse, error)

	// DeleteRows request  with any body
	DeleteRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*DeleteRowsResponse, error)

	DeleteRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*DeleteRowsResponse, error)

	// ListRows request
	ListRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*ListRowsResponse, error)

	// UpsertRows request  with any body
	UpsertRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*UpsertRowsResponse, error)

	UpsertRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*UpsertRowsResponse, error)

	// DeleteRow request
	DeleteRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*DeleteRowResponse, error)

	// GetRow request
	GetRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*GetRowResponse, error)

	// UpdateRow request  with any body
	UpdateRowWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*UpdateRowResponse, error)

	UpdateRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*UpdateRowResponse, error)

	// PushButton request
	PushButtonWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*PushButtonResponse, error)

	// GetMutationStatus request
	GetMutationStatusWithResponse(ctx context.Context, requestId RequestId) (*GetMutationStatusResponse, error)

	// ResolveBrowserLink request
	ResolveBrowserLinkWithResponse(ctx context.Context, params *ResolveBrowserLinkParams) (*ResolveBrowserLinkResponse, error)

	// Whoami request
	WhoamiWithResponse(ctx context.Context) (*WhoamiResponse, error)
}

type ListDocAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocAnalyticsDaily
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocCategoryList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDocsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Doc
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *DocDelete
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Doc
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclMetadata
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAclMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAclPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShareDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddPermissionResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ShareDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShareDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeletePermissionResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListControlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ControlList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListControlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListControlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Control
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFormulasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FormulaList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFormulasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFormulasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFormulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Formula
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFormulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFormulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON410 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PageUpdateResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpublishDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnpublishResult
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UnpublishDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpublishDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishDocResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PublishResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r PublishDocResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishDocResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnList
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ColumnDetail
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowsDeleteResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowList
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertRowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowsUpsertResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpsertRowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertRowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowDeleteResult
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RowDetail
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *RowUpdateResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateRowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PushButtonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *PushButtonResult
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r PushButtonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PushButtonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMutationStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MutationStatus
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMutationStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMutationStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveBrowserLinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiLink
	JSON400      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON401 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON403 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON404 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r ResolveBrowserLinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveBrowserLinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WhoamiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
	JSON429 *struct {

		// Any additional context on the error, or the same as `statusMessage` otherwise.
		Message string `json:"message"`

		// HTTP status code of the error.
		StatusCode float32 `json:"statusCode"`

		// HTTP status message of the error.
		StatusMessage string `json:"statusMessage"`
	}
}

// Status returns HTTPResponse.Status
func (r WhoamiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WhoamiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListDocAnalyticsWithResponse request returning *ListDocAnalyticsResponse
func (c *ClientWithResponses) ListDocAnalyticsWithResponse(ctx context.Context, params *ListDocAnalyticsParams) (*ListDocAnalyticsResponse, error) {
	rsp, err := c.ListDocAnalytics(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListDocAnalyticsResponse(rsp)
}

// ListCategoriesWithResponse request returning *ListCategoriesResponse
func (c *ClientWithResponses) ListCategoriesWithResponse(ctx context.Context) (*ListCategoriesResponse, error) {
	rsp, err := c.ListCategories(ctx)
	if err != nil {
		return nil, err
	}
	return ParseListCategoriesResponse(rsp)
}

// ListDocsWithResponse request returning *ListDocsResponse
func (c *ClientWithResponses) ListDocsWithResponse(ctx context.Context, params *ListDocsParams) (*ListDocsResponse, error) {
	rsp, err := c.ListDocs(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseListDocsResponse(rsp)
}

// CreateDocWithBodyWithResponse request with arbitrary body returning *CreateDocResponse
func (c *ClientWithResponses) CreateDocWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*CreateDocResponse, error) {
	rsp, err := c.CreateDocWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocResponse(rsp)
}

func (c *ClientWithResponses) CreateDocWithResponse(ctx context.Context, body CreateDocJSONRequestBody) (*CreateDocResponse, error) {
	rsp, err := c.CreateDoc(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseCreateDocResponse(rsp)
}

// DeleteDocWithResponse request returning *DeleteDocResponse
func (c *ClientWithResponses) DeleteDocWithResponse(ctx context.Context, docId DocId) (*DeleteDocResponse, error) {
	rsp, err := c.DeleteDoc(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDocResponse(rsp)
}

// GetDocWithResponse request returning *GetDocResponse
func (c *ClientWithResponses) GetDocWithResponse(ctx context.Context, docId DocId) (*GetDocResponse, error) {
	rsp, err := c.GetDoc(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseGetDocResponse(rsp)
}

// GetAclMetadataWithResponse request returning *GetAclMetadataResponse
func (c *ClientWithResponses) GetAclMetadataWithResponse(ctx context.Context, docId DocId) (*GetAclMetadataResponse, error) {
	rsp, err := c.GetAclMetadata(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseGetAclMetadataResponse(rsp)
}

// GetAclPermissionsWithResponse request returning *GetAclPermissionsResponse
func (c *ClientWithResponses) GetAclPermissionsWithResponse(ctx context.Context, docId DocId, params *GetAclPermissionsParams) (*GetAclPermissionsResponse, error) {
	rsp, err := c.GetAclPermissions(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseGetAclPermissionsResponse(rsp)
}

// ShareDocWithBodyWithResponse request with arbitrary body returning *ShareDocResponse
func (c *ClientWithResponses) ShareDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*ShareDocResponse, error) {
	rsp, err := c.ShareDocWithBody(ctx, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseShareDocResponse(rsp)
}

func (c *ClientWithResponses) ShareDocWithResponse(ctx context.Context, docId DocId, body ShareDocJSONRequestBody) (*ShareDocResponse, error) {
	rsp, err := c.ShareDoc(ctx, docId, body)
	if err != nil {
		return nil, err
	}
	return ParseShareDocResponse(rsp)
}

// DeletePermissionWithResponse request returning *DeletePermissionResponse
func (c *ClientWithResponses) DeletePermissionWithResponse(ctx context.Context, docId DocId, permissionId PermissionId) (*DeletePermissionResponse, error) {
	rsp, err := c.DeletePermission(ctx, docId, permissionId)
	if err != nil {
		return nil, err
	}
	return ParseDeletePermissionResponse(rsp)
}

// ListControlsWithResponse request returning *ListControlsResponse
func (c *ClientWithResponses) ListControlsWithResponse(ctx context.Context, docId DocId, params *ListControlsParams) (*ListControlsResponse, error) {
	rsp, err := c.ListControls(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListControlsResponse(rsp)
}

// GetControlWithResponse request returning *GetControlResponse
func (c *ClientWithResponses) GetControlWithResponse(ctx context.Context, docId DocId, controlIdOrName ControlIdOrName) (*GetControlResponse, error) {
	rsp, err := c.GetControl(ctx, docId, controlIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetControlResponse(rsp)
}

// ListFormulasWithResponse request returning *ListFormulasResponse
func (c *ClientWithResponses) ListFormulasWithResponse(ctx context.Context, docId DocId, params *ListFormulasParams) (*ListFormulasResponse, error) {
	rsp, err := c.ListFormulas(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListFormulasResponse(rsp)
}

// GetFormulaWithResponse request returning *GetFormulaResponse
func (c *ClientWithResponses) GetFormulaWithResponse(ctx context.Context, docId DocId, formulaIdOrName FormulaIdOrName) (*GetFormulaResponse, error) {
	rsp, err := c.GetFormula(ctx, docId, formulaIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetFormulaResponse(rsp)
}

// ListPagesWithResponse request returning *ListPagesResponse
func (c *ClientWithResponses) ListPagesWithResponse(ctx context.Context, docId DocId, params *ListPagesParams) (*ListPagesResponse, error) {
	rsp, err := c.ListPages(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListPagesResponse(rsp)
}

// GetPageWithResponse request returning *GetPageResponse
func (c *ClientWithResponses) GetPageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName) (*GetPageResponse, error) {
	rsp, err := c.GetPage(ctx, docId, pageIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetPageResponse(rsp)
}

// UpdatePageWithBodyWithResponse request with arbitrary body returning *UpdatePageResponse
func (c *ClientWithResponses) UpdatePageWithBodyWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, contentType string, body io.Reader) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePageWithBody(ctx, docId, pageIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

func (c *ClientWithResponses) UpdatePageWithResponse(ctx context.Context, docId DocId, pageIdOrName PageIdOrName, body UpdatePageJSONRequestBody) (*UpdatePageResponse, error) {
	rsp, err := c.UpdatePage(ctx, docId, pageIdOrName, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePageResponse(rsp)
}

// UnpublishDocWithResponse request returning *UnpublishDocResponse
func (c *ClientWithResponses) UnpublishDocWithResponse(ctx context.Context, docId DocId) (*UnpublishDocResponse, error) {
	rsp, err := c.UnpublishDoc(ctx, docId)
	if err != nil {
		return nil, err
	}
	return ParseUnpublishDocResponse(rsp)
}

// PublishDocWithBodyWithResponse request with arbitrary body returning *PublishDocResponse
func (c *ClientWithResponses) PublishDocWithBodyWithResponse(ctx context.Context, docId DocId, contentType string, body io.Reader) (*PublishDocResponse, error) {
	rsp, err := c.PublishDocWithBody(ctx, docId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePublishDocResponse(rsp)
}

func (c *ClientWithResponses) PublishDocWithResponse(ctx context.Context, docId DocId, body PublishDocJSONRequestBody) (*PublishDocResponse, error) {
	rsp, err := c.PublishDoc(ctx, docId, body)
	if err != nil {
		return nil, err
	}
	return ParsePublishDocResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, docId DocId, params *ListTablesParams) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, docId, params)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, docId, tableIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ListColumnsWithResponse request returning *ListColumnsResponse
func (c *ClientWithResponses) ListColumnsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListColumnsParams) (*ListColumnsResponse, error) {
	rsp, err := c.ListColumns(ctx, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	return ParseListColumnsResponse(rsp)
}

// GetColumnWithResponse request returning *GetColumnResponse
func (c *ClientWithResponses) GetColumnWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, columnIdOrName ColumnIdOrName) (*GetColumnResponse, error) {
	rsp, err := c.GetColumn(ctx, docId, tableIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseGetColumnResponse(rsp)
}

// DeleteRowsWithBodyWithResponse request with arbitrary body returning *DeleteRowsResponse
func (c *ClientWithResponses) DeleteRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, contentType string, body io.Reader) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRowsWithBody(ctx, docId, tableIdOrName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

func (c *ClientWithResponses) DeleteRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, body DeleteRowsJSONRequestBody) (*DeleteRowsResponse, error) {
	rsp, err := c.DeleteRows(ctx, docId, tableIdOrName, body)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowsResponse(rsp)
}

// ListRowsWithResponse request returning *ListRowsResponse
func (c *ClientWithResponses) ListRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *ListRowsParams) (*ListRowsResponse, error) {
	rsp, err := c.ListRows(ctx, docId, tableIdOrName, params)
	if err != nil {
		return nil, err
	}
	return ParseListRowsResponse(rsp)
}

// UpsertRowsWithBodyWithResponse request with arbitrary body returning *UpsertRowsResponse
func (c *ClientWithResponses) UpsertRowsWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, contentType string, body io.Reader) (*UpsertRowsResponse, error) {
	rsp, err := c.UpsertRowsWithBody(ctx, docId, tableIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRowsResponse(rsp)
}

func (c *ClientWithResponses) UpsertRowsWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, params *UpsertRowsParams, body UpsertRowsJSONRequestBody) (*UpsertRowsResponse, error) {
	rsp, err := c.UpsertRows(ctx, docId, tableIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpsertRowsResponse(rsp)
}

// DeleteRowWithResponse request returning *DeleteRowResponse
func (c *ClientWithResponses) DeleteRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName) (*DeleteRowResponse, error) {
	rsp, err := c.DeleteRow(ctx, docId, tableIdOrName, rowIdOrName)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRowResponse(rsp)
}

// GetRowWithResponse request returning *GetRowResponse
func (c *ClientWithResponses) GetRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *GetRowParams) (*GetRowResponse, error) {
	rsp, err := c.GetRow(ctx, docId, tableIdOrName, rowIdOrName, params)
	if err != nil {
		return nil, err
	}
	return ParseGetRowResponse(rsp)
}

// UpdateRowWithBodyWithResponse request with arbitrary body returning *UpdateRowResponse
func (c *ClientWithResponses) UpdateRowWithBodyWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, contentType string, body io.Reader) (*UpdateRowResponse, error) {
	rsp, err := c.UpdateRowWithBody(ctx, docId, tableIdOrName, rowIdOrName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowResponse(rsp)
}

func (c *ClientWithResponses) UpdateRowWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, params *UpdateRowParams, body UpdateRowJSONRequestBody) (*UpdateRowResponse, error) {
	rsp, err := c.UpdateRow(ctx, docId, tableIdOrName, rowIdOrName, params, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRowResponse(rsp)
}

// PushButtonWithResponse request returning *PushButtonResponse
func (c *ClientWithResponses) PushButtonWithResponse(ctx context.Context, docId DocId, tableIdOrName TableIdOrName, rowIdOrName RowIdOrName, columnIdOrName ColumnIdOrName) (*PushButtonResponse, error) {
	rsp, err := c.PushButton(ctx, docId, tableIdOrName, rowIdOrName, columnIdOrName)
	if err != nil {
		return nil, err
	}
	return ParsePushButtonResponse(rsp)
}

// GetMutationStatusWithResponse request returning *GetMutationStatusResponse
func (c *ClientWithResponses) GetMutationStatusWithResponse(ctx context.Context, requestId RequestId) (*GetMutationStatusResponse, error) {
	rsp, err := c.GetMutationStatus(ctx, requestId)
	if err != nil {
		return nil, err
	}
	return ParseGetMutationStatusResponse(rsp)
}

// ResolveBrowserLinkWithResponse request returning *ResolveBrowserLinkResponse
func (c *ClientWithResponses) ResolveBrowserLinkWithResponse(ctx context.Context, params *ResolveBrowserLinkParams) (*ResolveBrowserLinkResponse, error) {
	rsp, err := c.ResolveBrowserLink(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseResolveBrowserLinkResponse(rsp)
}

// WhoamiWithResponse request returning *WhoamiResponse
func (c *ClientWithResponses) WhoamiWithResponse(ctx context.Context) (*WhoamiResponse, error) {
	rsp, err := c.Whoami(ctx)
	if err != nil {
		return nil, err
	}
	return ParseWhoamiResponse(rsp)
}

// ParseListDocAnalyticsResponse parses an HTTP response from a ListDocAnalyticsWithResponse call
func ParseListDocAnalyticsResponse(rsp *http.Response) (*ListDocAnalyticsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDocAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocAnalyticsDaily
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListCategoriesResponse parses an HTTP response from a ListCategoriesWithResponse call
func ParseListCategoriesResponse(rsp *http.Response) (*ListCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocCategoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListDocsResponse parses an HTTP response from a ListDocsWithResponse call
func ParseListDocsResponse(rsp *http.Response) (*ListDocsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListDocsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseCreateDocResponse parses an HTTP response from a CreateDocWithResponse call
func ParseCreateDocResponse(rsp *http.Response) (*CreateDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Doc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteDocResponse parses an HTTP response from a DeleteDocWithResponse call
func ParseDeleteDocResponse(rsp *http.Response) (*DeleteDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DocDelete
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetDocResponse parses an HTTP response from a GetDocWithResponse call
func ParseGetDocResponse(rsp *http.Response) (*GetDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Doc
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAclMetadataResponse parses an HTTP response from a GetAclMetadataWithResponse call
func ParseGetAclMetadataResponse(rsp *http.Response) (*GetAclMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAclMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetAclPermissionsResponse parses an HTTP response from a GetAclPermissionsWithResponse call
func ParseGetAclPermissionsResponse(rsp *http.Response) (*GetAclPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAclPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseShareDocResponse parses an HTTP response from a ShareDocWithResponse call
func ParseShareDocResponse(rsp *http.Response) (*ShareDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ShareDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddPermissionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeletePermissionResponse parses an HTTP response from a DeletePermissionWithResponse call
func ParseDeletePermissionResponse(rsp *http.Response) (*DeletePermissionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeletePermissionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListControlsResponse parses an HTTP response from a ListControlsWithResponse call
func ParseListControlsResponse(rsp *http.Response) (*ListControlsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListControlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetControlResponse parses an HTTP response from a GetControlWithResponse call
func ParseGetControlResponse(rsp *http.Response) (*GetControlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Control
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListFormulasResponse parses an HTTP response from a ListFormulasWithResponse call
func ParseListFormulasResponse(rsp *http.Response) (*ListFormulasResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListFormulasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormulaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetFormulaResponse parses an HTTP response from a GetFormulaWithResponse call
func ParseGetFormulaResponse(rsp *http.Response) (*GetFormulaResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetFormulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Formula
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListPagesResponse parses an HTTP response from a ListPagesWithResponse call
func ParseListPagesResponse(rsp *http.Response) (*ListPagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetPageResponse parses an HTTP response from a GetPageWithResponse call
func ParseGetPageResponse(rsp *http.Response) (*GetPageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdatePageResponse parses an HTTP response from a UpdatePageWithResponse call
func ParseUpdatePageResponse(rsp *http.Response) (*UpdatePageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PageUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUnpublishDocResponse parses an HTTP response from a UnpublishDocWithResponse call
func ParseUnpublishDocResponse(rsp *http.Response) (*UnpublishDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UnpublishDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnpublishResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePublishDocResponse parses an HTTP response from a PublishDocWithResponse call
func ParsePublishDocResponse(rsp *http.Response) (*PublishDocResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PublishDocResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PublishResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListColumnsResponse parses an HTTP response from a ListColumnsWithResponse call
func ParseListColumnsResponse(rsp *http.Response) (*ListColumnsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetColumnResponse parses an HTTP response from a GetColumnWithResponse call
func ParseGetColumnResponse(rsp *http.Response) (*GetColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ColumnDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRowsResponse parses an HTTP response from a DeleteRowsWithResponse call
func ParseDeleteRowsResponse(rsp *http.Response) (*DeleteRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowsDeleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseListRowsResponse parses an HTTP response from a ListRowsWithResponse call
func ParseListRowsResponse(rsp *http.Response) (*ListRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpsertRowsResponse parses an HTTP response from a UpsertRowsWithResponse call
func ParseUpsertRowsResponse(rsp *http.Response) (*UpsertRowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpsertRowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowsUpsertResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteRowResponse parses an HTTP response from a DeleteRowWithResponse call
func ParseDeleteRowResponse(rsp *http.Response) (*DeleteRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowDeleteResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetRowResponse parses an HTTP response from a GetRowWithResponse call
func ParseGetRowResponse(rsp *http.Response) (*GetRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RowDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseUpdateRowResponse parses an HTTP response from a UpdateRowWithResponse call
func ParseUpdateRowResponse(rsp *http.Response) (*UpdateRowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateRowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest RowUpdateResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParsePushButtonResponse parses an HTTP response from a PushButtonWithResponse call
func ParsePushButtonResponse(rsp *http.Response) (*PushButtonResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PushButtonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PushButtonResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMutationStatusResponse parses an HTTP response from a GetMutationStatusWithResponse call
func ParseGetMutationStatusResponse(rsp *http.Response) (*GetMutationStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMutationStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MutationStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseResolveBrowserLinkResponse parses an HTTP response from a ResolveBrowserLinkWithResponse call
func ParseResolveBrowserLinkResponse(rsp *http.Response) (*ResolveBrowserLinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResolveBrowserLinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseWhoamiResponse parses an HTTP response from a WhoamiWithResponse call
func ParseWhoamiResponse(rsp *http.Response) (*WhoamiResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &WhoamiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {

			// Any additional context on the error, or the same as `statusMessage` otherwise.
			Message string `json:"message"`

			// HTTP status code of the error.
			StatusCode float32 `json:"statusCode"`

			// HTTP status message of the error.
			StatusMessage string `json:"statusMessage"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}
